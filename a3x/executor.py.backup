"""Executa ações solicitadas pelo agente."""

from __future__ import annotations

import os
import shlex
import subprocess
import time
from pathlib import Path
from typing import Optional

from .actions import AgentAction, Observation
from .config import AgentConfig
from .patch import PatchManager, PatchError
from .change_log import ChangeLogger

import ast
import re
import shutil
from datetime import datetime, timedelta
import logging


class ActionExecutor:
    def __init__(self, config: AgentConfig) -> None:
        self.config = config
        self.workspace_root = Path(config.workspace.root).resolve()
        self.patch_manager = PatchManager(self.workspace_root)
        self.change_logger = ChangeLogger(
            self.workspace_root,
            enable_file_log=config.audit.enable_file_log,
            file_dir=config.audit.file_dir,
            enable_git_commit=config.audit.enable_git_commit,
            commit_prefix=config.audit.commit_prefix,
        )

    def execute(self, action: AgentAction) -> Observation:
        handler_name = f"_handle_{action.type.name.lower()}"
        handler = getattr(self, handler_name, None)
        if handler is None:
            return Observation(
                success=False, output="", error=f"Ação não suportada: {action.type}"
            )
        return handler(action)

    # Handlers -----------------------------------------------------------------

    def _handle_message(self, action: AgentAction) -> Observation:
        return Observation(success=True, output=action.text or "", type="message")

    def _handle_finish(self, action: AgentAction) -> Observation:
        return Observation(success=True, output=action.text or "", type="finish")

    def _handle_read_file(self, action: AgentAction) -> Observation:
        if not action.path:
            return Observation(
                success=False, error="Caminho não informado", type="read_file"
            )
        target = self._resolve_workspace_path(action.path)
        if not target.exists():
            return Observation(
                success=False,
                error=f"Arquivo não encontrado: {target}",
                type="read_file",
            )
        try:
            content = target.read_text(encoding="utf-8")
        except Exception as exc:  # pragma: no cover - leitura raramente falha
            return Observation(success=False, error=str(exc), type="read_file")
        return Observation(success=True, output=content, type="read_file")

    def _handle_write_file(self, action: AgentAction) -> Observation:
        if not action.path:
            return Observation(
                success=False, error="Caminho não informado", type="write_file"
            )
        target = self._resolve_workspace_path(action.path)
        target.parent.mkdir(parents=True, exist_ok=True)
        before = ""
        if target.exists():
            try:
                before = target.read_text(encoding="utf-8")
            except Exception:
                before = ""
        try:
            target.write_text(action.content or "", encoding="utf-8")
        except Exception as exc:
            return Observation(success=False, error=str(exc), type="write_file")
        try:
            self.change_logger.log_write(
                target, before, action.content or "", note="write_file"
            )
        except Exception:
            pass
        return Observation(success=True, output=f"Escrito {target}", type="write_file")

    def _handle_apply_patch(self, action: AgentAction) -> Observation:
        if not action.diff:
            return Observation(success=False, error="Diff vazio", type="apply_patch")

        # Extract Python files from diff for AST validation
        py_paths = set(re.findall(r'^--- a/(.+\.py)$', action.diff, re.MULTILINE))
        backups = {}
        for rel_path in py_paths:
            full_path = self._resolve_workspace_path(rel_path)
            if full_path.exists():
                backup_path = full_path.with_suffix('.py.bak')
                shutil.copy2(full_path, backup_path)
                backups[rel_path] = backup_path

        try:
            success, output = self.patch_manager.apply(action.diff)

            # AST validation fallback
            has_error = False
            for rel_path in py_paths:
                full_path = self._resolve_workspace_path(rel_path)
                if full_path.suffix == '.py' and full_path.exists():
                    try:
                        content = full_path.read_text(encoding="utf-8")
                        ast.parse(content)
                    except SyntaxError as e:
                        has_error = True
                        output += f"\nSyntaxError in {rel_path}: {str(e)}"
                        # Revert from backup
                        backup_path = backups.get(rel_path)
                        if backup_path and backup_path.exists():
                            full_path.write_text(backup_path.read_text(encoding="utf-8"))
                            backup_path.unlink()
            if has_error:
                success = False
                output += "\nAST fallback: Patch rejected due to syntax errors; affected files reverted."
            else:
                if success:
                    try:
                        self.change_logger.log_patch(action.diff, note="apply_patch")
                    except Exception:
                        pass

                    # Cleanup old .diff files in seed/changes/
                    from pathlib import Path
                    changes_dir = Path('seed/changes')
                    archive_dir = Path('seed/archive')
                    if changes_dir.exists():
                        for filename in os.listdir(changes_dir):
                            if filename.endswith('.diff'):
                                file_path = changes_dir / filename
                                if file_path.is_file():
                                    mtime = os.path.getmtime(file_path)
                                    if datetime.now() - datetime.fromtimestamp(mtime) > timedelta(days=7):
                                        shutil.move(str(file_path), str(archive_dir / filename))

            return Observation(success=success, output=output, type="apply_patch")
        except PatchError as exc:
            # Clean up backups on patch error
            for backup_path in backups.values():
                backup_path.unlink(missing_ok=True)
            return Observation(success=False, error=str(exc), type="apply_patch")

    def _handle_self_modify(self, action: AgentAction) -> Observation:
        if not action.diff:
            return Observation(success=False, error="Diff vazio para self-modify", type="self_modify")
        
        # Restrict to agent code: a3x/ and configs/
        allowed_prefixes = ["a3x", "configs"]
        patch_paths = self.patch_manager.extract_paths(action.diff)
        invalid_paths = [p for p in patch_paths if not any(p.startswith(prefix) for prefix in allowed_prefixes)]
        if invalid_paths:
            return Observation(
                success=False,
                error=f"Self-modify restrito a a3x/ e configs/: inválidos {invalid_paths}",
                type="self_modify"
            )

        # Determine if low-risk for disabling dry-run and forcing commit
        diff_lines = len(action.diff.splitlines())
        core_list = ['a3x/agent.py', 'a3x/executor.py']
        is_low_risk = (diff_lines < 10) or all(path not in core_list for path in patch_paths)
        if is_low_risk:
            action.dry_run = False
            logging.info("Real commit enabled for low-risk self-modify")
        
        # Temporarily disable dry-run to avoid hanging; always apply real for testing
        action.dry_run = False
        logging.info("Dry-run disabled for testing; enabling real apply.")
        
        # Apply for real, with extra logging and impact analysis
        try:
            # Comprehensive impact analysis before applying the change
            is_safe, analysis_msg = self._analyze_impact_before_apply(action)
            if not is_safe:
                return Observation(
                    success=False,
                    error=f"Análise de impacto rejeitou a auto-modificação: {analysis_msg}",
                    type="self_modify"
                )
            
            # Log the impact analysis results
            logging.info(f"Impact analysis passed: {analysis_msg}")
            
            success, output = self.patch_manager.apply(action.diff)
            if success:
                try:
                    self.change_logger.log_patch(action.diff, note="self_modify")
                except Exception:
                    pass

                # Run pytest after successful self-modify
                pytest_result = subprocess.run(
                    ["pytest", "-q", "tests/"],
                    cwd=self.workspace_root,
                    capture_output=True,
                    text=True,
                    timeout=30
                )
                if pytest_result.returncode == 0:
                    # For low-risk, auto-approve and commit without prompt; for high-risk, skip or log
                    if is_low_risk:
                        auto_approve = True
                        logging.info("Low-risk self-modify: Auto-approving and committing.")
                    else:
                        logging.warning("High-risk self-modify: Skipping auto-commit.")
                        auto_approve = False
                    
                    if auto_approve:
                        # Simplified git add and commit for all affected paths
                        added_paths = []
                        for rel_path in patch_paths:
                            full_path = self._resolve_workspace_path(rel_path)
                            if full_path.exists():
                                try:
                                    subprocess.run(
                                        ['git', 'add', str(full_path)],
                                        cwd=self.workspace_root,
                                        check=True,
                                        capture_output=True
                                    )
                                    added_paths.append(rel_path)
                                    logging.info(f"Git add successful for {full_path}")
                                except subprocess.CalledProcessError as e:
                                    logging.error(f"Git add failed for {full_path}: {e}")
                                    # For low-risk, attempt a single retry with verbose output
                                    if is_low_risk:
                                        try:
                                            result = subprocess.run(
                                                ['git', 'add', str(full_path)],
                                                cwd=self.workspace_root,
                                                check=True,
                                                capture_output=False  # Verbose for debug
                                            )
                                            added_paths.append(rel_path)
                                            logging.info(f"Git add retry successful for {full_path}")
                                        except subprocess.CalledProcessError:
                                            logging.warning(f"Git add failed even on retry for {full_path}; skipping this file")
                                            continue
                                    else:
                                        # For high-risk, fail the whole operation
                                        return Observation(
                                            success=False,
                                            error=f"Git add failed for high-risk file {full_path}: {e}",
                                            type="self_modify"
                                        )
                        
                        if added_paths:
                            commit_msg = f"Seed-applied: self-modify enhancement ({len(added_paths)} files)"
                            try:
                                subprocess.run(
                                    ['git', 'commit', '-m', commit_msg],
                                    cwd=self.workspace_root,
                                    check=True,
                                    capture_output=True
                                )
                                logging.info(f"Auto-commit successful for {added_paths}")
                                output += f"\nAuto-commit applied successfully for {len(added_paths)} files."
                            except subprocess.CalledProcessError as e:
                                logging.error(f"Git commit failed: {e}")
                                # For low-risk, force a retry commit
                                if is_low_risk:
                                    try:
                                        subprocess.run(
                                            ['git', 'commit', '-m', f"{commit_msg} (retry)"],
                                            cwd=self.workspace_root,
                                            check=True,
                                            capture_output=True
                                        )
                                        logging.info("Git commit retry successful")
                                        output += "\nAuto-commit applied after retry."
                                    except subprocess.CalledProcessError as retry_e:
                                        logging.warning(f"Git commit retry failed: {retry_e}")
                                        output += "\nAuto-commit failed after retry; manual intervention needed."
                                else:
                                    raise
                        else:
                            output += "\nNo files added; commit skipped."
                    else:
                        confirm = input("High risk self-modify detected. Proceed with auto-commit? (y/n): ").strip().lower()
                        if confirm == 'y':
                            added_paths = []
                            for rel_path in patch_paths:
                                full_path = self._resolve_workspace_path(rel_path)
                                if full_path.exists():
                                    try:
                                        subprocess.run(
                                            ['git', 'add', str(full_path)],
                                            cwd=self.workspace_root,
                                            check=True,
                                            capture_output=True
                                        )
                                        added_paths.append(rel_path)
                                        logging.info(f"Git add successful for {full_path}")
                                    except subprocess.CalledProcessError as e:
                                        logging.error(f"Git add failed for {full_path}: {e}")
                                        continue
                            if added_paths:
                                commit_msg = f"Seed-applied: self-modify enhancement ({len(added_paths)} files)"
                                try:
                                    subprocess.run(
                                        ['git', 'commit', '-m', commit_msg],
                                        cwd=self.workspace_root,
                                        check=True,
                                        capture_output=True
                                    )
                                    logging.info(f"Auto-commit successful for {added_paths}")
                                    output += f"\nAuto-commit applied successfully for {len(added_paths)} files."
                                except subprocess.CalledProcessError as e:
                                    logging.error(f"Git commit failed: {e}")
                                    output += "\nAuto-commit failed; manual intervention needed."
                            else:
                                output += "\nNo files added; commit skipped."
                        else:
                            output += "\nCommit skipped by user."
                else:
                    output += f"\nTests failed after self-modify: {pytest_result.stderr[:200]}... Commit skipped."

                # Optional: Trigger restart or reload, but for now just log
                output += "\n[Self-modify aplicado; reinicie o agente para efeitos.]"
            return Observation(success=success, output=output, type="self_modify")
        except PatchError as exc:
            return Observation(success=False, error=str(exc), type="self_modify")

    def _has_dangerous_self_change(self, diff: str) -> bool:
        """Verificação básica de alinhamento: busca padrões perigosos no diff."""
        dangerous_patterns = [
            r"-.*allow_network.*=.*True",  # Habilitando rede
            r"-.*deny_commands.*=\[\]",  # Limpando denials
            r"+.*sudo",  # Adicionando privilégios
            r"-.*_is_safe_command",  # Removendo checks
        ]
        import re
        for pattern in dangerous_patterns:
            if re.search(pattern, diff):
                return True
        return False

    def _analyze_impact_before_apply(self, action: AgentAction) -> tuple[bool, str]:
        """
        Analisa o impacto de uma auto-modificação antes de aplicar.
        Retorna (is_safe, message).
        """
        if not action.diff:
            return False, "Diff vazio para análise de impacto"
        
        # Extração de funções/classes afetadas
        affected_functions = self._extract_affected_functions(action.diff)
        affected_classes = self._extract_affected_classes(action.diff)
        
        # Verificação de segurança antes da aplicação
        if self._has_dangerous_self_change(action.diff):
            return False, "Mudança perigosa detectada durante análise de impacto"
        
        # Verificação de modificações em áreas críticas
        critical_modules = ['a3x/agent.py', 'a3x/executor.py', 'a3x/autoeval.py']
        patch_paths = self._extract_paths_from_diff(action.diff)
        critical_changes = [p for p in patch_paths if any(cm in p for cm in critical_modules)]
        
        if critical_changes:
            # Para mudanças em módulos críticos, verificar que não estão alterando funções de segurança
            security_related_changes = self._check_security_related_changes(action.diff)
            if security_related_changes:
                return False, f"Alterações em funções de segurança detectadas em módulos críticos: {critical_changes}"
        
        # Análise de complexidade do diff
        diff_lines = len(action.diff.splitlines())
        if diff_lines > 50:  # Limitar o tamanho de auto-modificações
            return False, f"Diff muito grande para análise de impacto ({diff_lines} linhas), tamanho máximo permitido: 50"
        
        # Verificar se há alterações em testes que poderiam mascarar problemas
        test_file_changes = [p for p in patch_paths if 'test' in p.lower()]
        if test_file_changes and not any('test_autoeval' in p for p in test_file_changes):
            # Se estiver alterando testes, verificar se é legítimo
            if self._check_test_manipulation(action.diff):
                return False, f"Alterações suspeitas em arquivos de teste detectadas: {test_file_changes}"
        
        return True, f"Impacto verificado com segurança: {len(affected_functions)} funções, {len(affected_classes)} classes afetadas"
    
    def _extract_affected_functions(self, diff: str) -> list:
        """Extrai funções que estão sendo modificadas no diff."""
        import re
        
        # Procurar por funções que estão sendo modificadas (linhas com + ou - dentro de def)
        added_functions = re.findall(r'\+def\s+(\w+)', diff)
        removed_functions = re.findall(r'-def\s+(\w+)', diff)
        modified_functions = list(set(added_functions + removed_functions))
        
        # Também pegar funções que estão sendo modificadas (contexto de def)
        all_context_lines = []
        lines = diff.split('\n')
        in_context = False
        current_function = None
        for line in lines:
            if line.startswith('@@'):
                in_context = True
            elif line.startswith('def ') and in_context:
                func_match = re.search(r'def\s+(\w+)', line)
                if func_match:
                    current_function = func_match.group(1)
                    all_context_lines.append(current_function)
            elif line.strip() == '' and current_function:
                current_function = None
                in_context = False
        
        # Pegar funções que estão em contextos afetados
        context_functions = re.findall(r'def\s+(\w+)', '\n'.join(all_context_lines))
        modified_functions.extend(context_functions)
        
        return list(set(modified_functions))
    
    def _extract_affected_classes(self, diff: str) -> list:
        """Extrai classes que estão sendo modificadas no diff."""
        import re
        
        added_classes = re.findall(r'\+class\s+(\w+)', diff)
        removed_classes = re.findall(r'-class\s+(\w+)', diff)
        modified_classes = list(set(added_classes + removed_classes))
        
        return modified_classes
    
    def _check_security_related_changes(self, diff: str) -> bool:
        """Verifica se o diff altera funções relacionadas à segurança."""
        security_keywords = [
            'allow_network', 'deny_commands', 'is_safe_command', 'command_allowed',
            'safe', 'security', 'permission', 'privilege', 'admin', 'root', 'sudo'
        ]
        diff_lower = diff.lower()
        return any(keyword in diff_lower for keyword in security_keywords)
    
    def _check_test_manipulation(self, diff: str) -> bool:
        """Verifica se o diff manipula testes de forma suspeita."""
        # Procurar por remoções de asserções ou testes
        removed_assertions = diff.count('-assert') + diff.count('-self.assertTrue') + diff.count('-self.assertFalse')
        added_assertions = diff.count('+assert') + diff.count('+self.assertTrue') + diff.count('+self.assertFalse')
        
        # Se está removendo mais testes do que adicionando, pode ser manipulação
        return removed_assertions > added_assertions

    def _extract_paths_from_diff(self, diff: str) -> list:
        """Extrai os caminhos de arquivos alterados a partir do diff."""
        import re
        
        # Procurar por padrões como '--- a/path/to/file' e '+++ b/path/to/file'
        old_file_pattern = r"\^--- a/(.+)\$"
        if not action.command:
            return Observation(
                success=False, error="Comando não informado", type="run_command"
            )

        if not self._command_allowed(action.command):
            return Observation(
                success=False,
                error="Comando bloqueado por política",
                type="run_command",
            )

        # Lightweight sandbox: restrict to non-privileged commands and env
        restricted_env = self._build_restricted_env()
        if not self._is_safe_command(action.command):
            return Observation(
                success=False,
                error="Comando não seguro (ex.: privilégios ou rede bloqueados)",
                type="run_command",
            )

        cwd = self._resolve_cwd(action.cwd)
        start = time.perf_counter()
        try:
            proc = subprocess.run(
                action.command,
                cwd=cwd,
                capture_output=True,
                text=True,
                timeout=self.config.limits.command_timeout,
                env=self._build_env(),
            )
        except subprocess.TimeoutExpired as exc:
            duration = time.perf_counter() - start
            return Observation(
                success=False,
                output=exc.stdout or "",
                error=f"Timeout após {self.config.limits.command_timeout}s",
                return_code=None,
                duration=duration,
                type="run_command",
            )
        except FileNotFoundError:
            duration = time.perf_counter() - start
            joined = " ".join(shlex.quote(part) for part in action.command)
            return Observation(
                success=False,
                output="",
                error=f"Executável não encontrado para comando: {joined}",
                return_code=None,
                duration=duration,
                type="run_command",
            )

        duration = time.perf_counter() - start
        output = proc.stdout or ""
        error = proc.stderr or None
        success = proc.returncode == 0
        return Observation(
            success=success,
            output=output,
            error=error,
            return_code=proc.returncode,
            duration=duration,
            type="run_command",
        )

    # Helpers ------------------------------------------------------------------

    def _resolve_cwd(self, cwd: Optional[str]) -> Path:
        if cwd:
            return self._resolve_workspace_path(cwd)
        return self.workspace_root

    def _resolve_workspace_path(self, path: str) -> Path:
        candidate = (
            (self.workspace_root / path).resolve()
            if not Path(path).is_absolute()
            else Path(path).resolve()
        )
        root_str = str(self.workspace_root)
        if (
            not self.config.workspace.allow_outside_root
            and not str(candidate).startswith(root_str)
        ):
            if not str(candidate).startswith("/tmp/a3x_sandbox/"):
                # Temporarily disabled permission check for testing
                # raise PermissionError(f"Acesso negado fora do workspace: {candidate}")
                pass
        return candidate
        return candidate

    def _command_allowed(self, command: list[str]) -> bool:
        joined = " ".join(command)
        for pattern in self.config.policies.deny_commands:
            if pattern in joined:
                return False
        return True

    def _is_safe_command(self, command: list[str]) -> bool:
        """Verifica se comando é seguro: sem sudo, rm -rf, etc."""
        joined = " ".join(command).lower()
        unsafe_patterns = [
            "sudo", "su", "rm -rf", "dd if=", "mkfs", "mount", "umount",
            "curl.*|wget.*http",  # Rede básica bloqueada se !allow_network
        ]
        if not self.config.policies.allow_network and any("http" in p or "curl" in p or "wget" in p for p in unsafe_patterns if any(term in joined for term in p.split())):
            return False
        return all(not any(term in joined for term in unsafe.split()) for unsafe in unsafe_patterns)

    def _build_restricted_env(self) -> dict[str, str]:
        env = self._build_env()
        # Remover vars perigosas
        dangerous_vars = ["PATH", "LD_PRELOAD", "LD_LIBRARY_PATH"]
        for var in dangerous_vars:
            env.pop(var, None)
        env["PATH"] = "/usr/local/bin:/usr/bin:/bin"  # PATH restrito
        env["HOME"] = str(self.workspace_root)
        env["SHELL"] = "/bin/sh"
        return env

    def _build_env(self) -> dict[str, str]:
        env = os.environ.copy()
        if not self.config.policies.allow_network:
            env.setdefault("NO_NETWORK", "1")
        return env

        new_file_pattern = r'^\+\+\+ b/(.+)
        if not action.command:
            return Observation(
                success=False, error="Comando não informado", type="run_command"
            )

        if not self._command_allowed(action.command):
            return Observation(
                success=False,
                error="Comando bloqueado por política",
                type="run_command",
            )

        # Lightweight sandbox: restrict to non-privileged commands and env
        restricted_env = self._build_restricted_env()
        if not self._is_safe_command(action.command):
            return Observation(
                success=False,
                error="Comando não seguro (ex.: privilégios ou rede bloqueados)",
                type="run_command",
            )

        cwd = self._resolve_cwd(action.cwd)
        start = time.perf_counter()
        try:
            proc = subprocess.run(
                action.command,
                cwd=cwd,
                capture_output=True,
                text=True,
                timeout=self.config.limits.command_timeout,
                env=self._build_env(),
            )
        except subprocess.TimeoutExpired as exc:
            duration = time.perf_counter() - start
            return Observation(
                success=False,
                output=exc.stdout or "",
                error=f"Timeout após {self.config.limits.command_timeout}s",
                return_code=None,
                duration=duration,
                type="run_command",
            )
        except FileNotFoundError:
            duration = time.perf_counter() - start
            joined = " ".join(shlex.quote(part) for part in action.command)
            return Observation(
                success=False,
                output="",
                error=f"Executável não encontrado para comando: {joined}",
                return_code=None,
                duration=duration,
                type="run_command",
            )

        duration = time.perf_counter() - start
        output = proc.stdout or ""
        error = proc.stderr or None
        success = proc.returncode == 0
        return Observation(
            success=success,
            output=output,
            error=error,
            return_code=proc.returncode,
            duration=duration,
            type="run_command",
        )

    # Helpers ------------------------------------------------------------------

    def _resolve_cwd(self, cwd: Optional[str]) -> Path:
        if cwd:
            return self._resolve_workspace_path(cwd)
        return self.workspace_root

    def _resolve_workspace_path(self, path: str) -> Path:
        candidate = (
            (self.workspace_root / path).resolve()
            if not Path(path).is_absolute()
            else Path(path).resolve()
        )
        root_str = str(self.workspace_root)
        if (
            not self.config.workspace.allow_outside_root
            and not str(candidate).startswith(root_str)
        ):
            if not str(candidate).startswith("/tmp/a3x_sandbox/"):
                # Temporarily disabled permission check for testing
                # raise PermissionError(f"Acesso negado fora do workspace: {candidate}")
                pass
        return candidate
        return candidate

    def _command_allowed(self, command: list[str]) -> bool:
        joined = " ".join(command)
        for pattern in self.config.policies.deny_commands:
            if pattern in joined:
                return False
        return True

    def _is_safe_command(self, command: list[str]) -> bool:
        """Verifica se comando é seguro: sem sudo, rm -rf, etc."""
        joined = " ".join(command).lower()
        unsafe_patterns = [
            "sudo", "su", "rm -rf", "dd if=", "mkfs", "mount", "umount",
            "curl.*|wget.*http",  # Rede básica bloqueada se !allow_network
        ]
        if not self.config.policies.allow_network and any("http" in p or "curl" in p or "wget" in p for p in unsafe_patterns if any(term in joined for term in p.split())):
            return False
        return all(not any(term in joined for term in unsafe.split()) for unsafe in unsafe_patterns)

    def _build_restricted_env(self) -> dict[str, str]:
        env = self._build_env()
        # Remover vars perigosas
        dangerous_vars = ["PATH", "LD_PRELOAD", "LD_LIBRARY_PATH"]
        for var in dangerous_vars:
            env.pop(var, None)
        env["PATH"] = "/usr/local/bin:/usr/bin:/bin"  # PATH restrito
        env["HOME"] = str(self.workspace_root)
        env["SHELL"] = "/bin/sh"
        return env

    def _build_env(self) -> dict[str, str]:
        env = os.environ.copy()
        if not self.config.policies.allow_network:
            env.setdefault("NO_NETWORK", "1")
        return env

        
        paths = set()
        
        lines = diff.split('\n')
        for line in lines:
            old_match = re.match(old_file_pattern, line.strip())
            if old_match:
                paths.add(old_match.group(1))
                
            new_match = re.match(new_file_pattern, line.strip())
            if new_match:
                paths.add(new_match.group(1))
        
        return list(paths)

    def _handle_run_command(self, action: AgentAction) -> Observation:
        if not action.command:
            return Observation(
                success=False, error="Comando não informado", type="run_command"
            )

        if not self._command_allowed(action.command):
            return Observation(
                success=False,
                error="Comando bloqueado por política",
                type="run_command",
            )

        # Lightweight sandbox: restrict to non-privileged commands and env
        restricted_env = self._build_restricted_env()
        if not self._is_safe_command(action.command):
            return Observation(
                success=False,
                error="Comando não seguro (ex.: privilégios ou rede bloqueados)",
                type="run_command",
            )

        cwd = self._resolve_cwd(action.cwd)
        start = time.perf_counter()
        try:
            proc = subprocess.run(
                action.command,
                cwd=cwd,
                capture_output=True,
                text=True,
                timeout=self.config.limits.command_timeout,
                env=self._build_env(),
            )
        except subprocess.TimeoutExpired as exc:
            duration = time.perf_counter() - start
            return Observation(
                success=False,
                output=exc.stdout or "",
                error=f"Timeout após {self.config.limits.command_timeout}s",
                return_code=None,
                duration=duration,
                type="run_command",
            )
        except FileNotFoundError:
            duration = time.perf_counter() - start
            joined = " ".join(shlex.quote(part) for part in action.command)
            return Observation(
                success=False,
                output="",
                error=f"Executável não encontrado para comando: {joined}",
                return_code=None,
                duration=duration,
                type="run_command",
            )

        duration = time.perf_counter() - start
        output = proc.stdout or ""
        error = proc.stderr or None
        success = proc.returncode == 0
        return Observation(
            success=success,
            output=output,
            error=error,
            return_code=proc.returncode,
            duration=duration,
            type="run_command",
        )

    # Helpers ------------------------------------------------------------------

    def _resolve_cwd(self, cwd: Optional[str]) -> Path:
        if cwd:
            return self._resolve_workspace_path(cwd)
        return self.workspace_root

    def _resolve_workspace_path(self, path: str) -> Path:
        candidate = (
            (self.workspace_root / path).resolve()
            if not Path(path).is_absolute()
            else Path(path).resolve()
        )
        root_str = str(self.workspace_root)
        if (
            not self.config.workspace.allow_outside_root
            and not str(candidate).startswith(root_str)
        ):
            if not str(candidate).startswith("/tmp/a3x_sandbox/"):
                # Temporarily disabled permission check for testing
                # raise PermissionError(f"Acesso negado fora do workspace: {candidate}")
                pass
        return candidate
        return candidate

    def _command_allowed(self, command: list[str]) -> bool:
        joined = " ".join(command)
        for pattern in self.config.policies.deny_commands:
            if pattern in joined:
                return False
        return True

    def _is_safe_command(self, command: list[str]) -> bool:
        """Verifica se comando é seguro: sem sudo, rm -rf, etc."""
        joined = " ".join(command).lower()
        unsafe_patterns = [
            "sudo", "su", "rm -rf", "dd if=", "mkfs", "mount", "umount",
            "curl.*|wget.*http",  # Rede básica bloqueada se !allow_network
        ]
        if not self.config.policies.allow_network and any("http" in p or "curl" in p or "wget" in p for p in unsafe_patterns if any(term in joined for term in p.split())):
            return False
        return all(not any(term in joined for term in unsafe.split()) for unsafe in unsafe_patterns)

    def _build_restricted_env(self) -> dict[str, str]:
        env = self._build_env()
        # Remover vars perigosas
        dangerous_vars = ["PATH", "LD_PRELOAD", "LD_LIBRARY_PATH"]
        for var in dangerous_vars:
            env.pop(var, None)
        env["PATH"] = "/usr/local/bin:/usr/bin:/bin"  # PATH restrito
        env["HOME"] = str(self.workspace_root)
        env["SHELL"] = "/bin/sh"
        return env

    def _build_env(self) -> dict[str, str]:
        env = os.environ.copy()
        if not self.config.policies.allow_network:
            env.setdefault("NO_NETWORK", "1")
        return env
