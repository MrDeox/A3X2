--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -3,63 +3,63 @@
 import subprocess
 import re
 
-# Security checks
-def validate_path(path):
-    if not os.path.exists(path):
-        raise ValueError(f"Path does not exist: {path}")
-    if '..' in path or not os.path.abspath(path).startswith(os.getcwd()):
-        raise ValueError(f"Unsafe path detected: {path}")
-    return path
+# Função para validar o patch
+ def validate_patch(patch_content):
+    # Verificações básicas de segurança
+    if 'rm -rf' in patch_content or 'del /f /q' in patch_content:
+        return False, 'Patch contém comandos perigosos de remoção'
+    if len(patch_content) > 10000:  # Limite de tamanho
+        return False, 'Patch muito grande, risco de overflow'
+    # Verificar se é um diff válido
+    if not re.search(r'^diff --git', patch_content, re.MULTILINE):
+        return False, 'Formato de patch inválido'
+    return True, 'Patch válido'
 
-def validate_diff_content(diff):
-    # Check for dangerous commands like rm, del, etc.
-    dangerous_patterns = [r'rm\s', r'del\s', r'format\s', r'\bexec\b']
-    for pattern in dangerous_patterns:
-        if re.search(pattern, diff, re.IGNORECASE):
-            raise ValueError(f"Dangerous command detected in diff: {pattern}")
-    return diff
+# Função principal para aplicar patch com segurança
+def apply_secure_patch(patch_file, target_dir):
+    if not os.path.exists(patch_file):
+        print('Arquivo de patch não encontrado')
+        return False
+    
+    with open(patch_file, 'r') as f:
+        patch_content = f.read()
+    
+    is_valid, message = validate_patch(patch_content)
+    if not is_valid:
+        print(f'Falha na validação: {message}')
+        return False
+    
+    # Verificar permissões do diretório alvo
+    if not os.path.exists(target_dir):
+        print('Diretório alvo não existe')
+        return False
+    if not os.access(target_dir, os.W_OK):
+        print('Sem permissão de escrita no diretório alvo')
+        return False
+    
+    # Aplicar o patch usando subprocess com sandboxing básico
+    cmd = ['patch', '-p1', '-d', target_dir]
+    try:
+        result = subprocess.run(cmd, input=patch_content, text=True, capture_output=True, timeout=30)
+        if result.returncode == 0:
+            print('Patch aplicado com sucesso')
+            return True
+        else:
+            print(f'Falha ao aplicar patch: {result.stderr}')
+            return False
+    except subprocess.TimeoutExpired:
+        print('Aplicação do patch excedeu o tempo limite')
+        return False
+    except Exception as e:
+        print(f'Erro inesperado: {e}')
+        return False
 
-def apply_patch_safely(patch_file, target_file):
-    target_file = validate_path(target_file)
-    with open(patch_file, 'r') as f:
-        diff_content = f.read()
-    validate_diff_content(diff_content)
+if __name__ == '__main__':
+    if len(sys.argv) != 3:
+        print('Uso: python patch.py <patch_file> <target_dir>')
+        sys.exit(1)
     
-    # Backup original file
-    backup = target_file + '.backup'
-    if os.path.exists(backup):
-        os.remove(backup)
-    os.rename(target_file, backup)
+    patch_file = sys.argv[1]
+    target_dir = sys.argv[2]
     
-    try:
-        result = subprocess.run(['patch', '-p1', '-i', patch_file, '--directory=' + os.path.dirname(target_file)], 
-                                capture_output=True, text=True, check=True)
-        if result.returncode != 0:
-            raise subprocess.CalledProcessError(result.returncode, 'patch', output=result.stdout + result.stderr)
-        print("Patch applied successfully.")
-    except subprocess.CalledProcessError as e:
-        print(f"Patch failed: {e}")
-        # Restore backup
-        os.rename(backup, target_file)
-        raise
-    except Exception as e:
-        print(f"Error: {e}")
-        # Restore backup
-        if os.path.exists(backup):
-            os.rename(backup, target_file)
-        raise
-
-if __name__ == "__main__":
-    if len(sys.argv) != 3:
-        print("Usage: python patch.py <patch_file> <target_file>")
-        sys.exit(1)
-    patch_file = sys.argv[1]
-    target_file = sys.argv[2]
-    try:
-        apply_patch_safely(patch_file, target_file)
-    except ValueError as e:
-        print(f"Security validation failed: {e}")
-        sys.exit(1)
-    except Exception as e:
-        print(f"Application failed: {e}")
-        sys.exit(1)
+    apply_secure_patch(patch_file, target_dir)
