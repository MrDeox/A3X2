--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -2,67 +2,66 @@
 import sys
 import os
 import subprocess
+import tempfile
+import difflib
+
+# Security checks before applying any patch
+def security_check(patch_content, target_file):
+    # Check for dangerous commands or patterns in patch
+    dangerous_patterns = [
+        r'rm -rf',
+        r'dd if=',
+        r'chmod 777',
+        r'sudo',
+        r'exec',
+        r'eval'
+    ]
+    for pattern in dangerous_patterns:
+        if re.search(pattern, patch_content, re.IGNORECASE):
+            raise ValueError(f"Dangerous pattern detected: {pattern}")
+    
+    # Ensure target file is writable and not system file
+    if os.path.exists(target_file):
+        if not os.access(target_file, os.W_OK):
+            raise PermissionError(f"Cannot write to {target_file}")
+        if target_file.startswith('/etc/') or target_file.startswith('/bin/'):
+            raise ValueError(f"Cannot patch system file: {target_file}")
+    
+    return True
+
 import re
-import hashlib
 
-class SecurePatcher:
-    def __init__(self):
-        self.risk_keywords = ['rm -rf', 'del /f', 'format', 'exec', ';', '|', '&', 'sudo', 'chmod +x']
-        self.max_patch_size = 10240  # 10KB limit
+def apply_patch(patch_file, target_file):
+    with open(patch_file, 'r') as f:
+        patch_content = f.read()
+    
+    if not security_check(patch_content, target_file):
+        return False
+    
+    # Proceed with patch application using subprocess
+    try:
+        result = subprocess.run(['patch', '-p1', '--dry-run', target_file], input=patch_content, text=True, capture_output=True)
+        if result.returncode != 0:
+            print("Dry run failed, not applying.")
+            return False
+        
+        result = subprocess.run(['patch', '-p1', target_file], input=patch_content, text=True, capture_output=True)
+        if result.returncode == 0:
+            print("Patch applied successfully.")
+            return True
+        else:
+            print(f"Patch failed: {result.stderr}")
+            return False
+    except Exception as e:
+        print(f"Error applying patch: {e}")
+        return False
 
-    def validate_patch(self, patch_content):
-        if len(patch_content) > self.max_patch_size:
-            return False, 'Patch too large'
-        for keyword in self.risk_keywords:
-            if re.search(re.escape(keyword), patch_content, re.IGNORECASE):
-                return False, f'Risky keyword detected: {keyword}'
-        # Check hash or signature if needed
-        return True, 'Valid'
-
-    def backup_file(self, target_file):
-        if os.path.exists(target_file):
-            backup = target_file + '.bak'
-            os.rename(target_file, backup)
-            return backup
-        return None
-
-    def apply_secure_patch(self, patch_content, target_file):
-        valid, msg = self.validate_patch(patch_content)
-        if not valid:
-            print(f'Security check failed: {msg}')
-            return False
-
-        backup = self.backup_file(target_file)
-        print(f'Backup created: {backup}')
-
-        try:
-            result = subprocess.run(
-                ['patch', '-p0', '--backup', '--verbose', target_file],
-                input=patch_content,
-                text=True,
-                capture_output=True,
-                check=True
-            )
-            print('Patch applied successfully')
-            return True
-        except subprocess.CalledProcessError as e:
-            print(f'Patch application failed: {e}')
-            if backup:
-                os.rename(backup, target_file)
-                print('Restored from backup')
-            return False
-
-if __name__ == '__main__':
-    if len(sys.argv) < 3:
-        print('Usage: python patch.py <patch_file> <target_file>')
+if __name__ == "__main__":
+    if len(sys.argv) != 3:
+        print("Usage: python3 patch.py <patch_file> <target_file>")
         sys.exit(1)
-
+    
     patch_file = sys.argv[1]
     target_file = sys.argv[2]
-
-    with open(patch_file, 'r') as f:
-        patch_content = f.read()
-
-    patcher = SecurePatcher()
-    success = patcher.apply_secure_patch(patch_content, target_file)
-    sys.exit(0 if success else 1)
+    
+    apply_patch(patch_file, target_file)