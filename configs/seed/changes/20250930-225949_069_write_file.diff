--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,74 +1,74 @@
 import sys
 import os
 import subprocess
-import re
-import hashlib
+import argparse
 
- def validate_patch_content(patch_content):
-    # Verificação básica: o patch deve conter linhas de diff
-    if not re.search(r'^\+\+\+', patch_content, re.MULTILINE):
-        return False, "Patch inválido: não encontrado cabeçalho de arquivo."
-    # Verificar por comandos perigosos (ex: rm, exec)
-    dangerous_patterns = [r'rm\s', r'exec\(', r'subprocess\.call\(']
-    for pattern in dangerous_patterns:
-        if re.search(pattern, patch_content, re.IGNORECASE):
-            return False, f"Patch rejeitado: conteúdo perigoso detectado ({pattern})."
-    return True, "OK"
 
- def compute_file_hash(filepath):
-    hasher = hashlib.sha256()
-    with open(filepath, 'rb') as f:
-        for chunk in iter(lambda: f.read(4096), b''):
-            hasher.update(chunk)
-    return hasher.hexdigest()
+def validate_patch_file(patch_path):
+    if not os.path.exists(patch_path):
+        raise ValueError(f"Patch file {patch_path} does not exist.")
+    if not os.path.isfile(patch_path):
+        raise ValueError(f"{patch_path} is not a file.")
+    if not os.access(patch_path, os.R_OK):
+        raise ValueError(f"Patch file {patch_path} is not readable.")
 
- def apply_secure_patch(target_file, patch_file):
-    if not os.path.exists(target_file):
-        return False, "Arquivo alvo não existe."
-    
-    # Verificar permissões: não aplicar em arquivos de sistema
-    if target_file.startswith('/etc/') or target_file.startswith('/bin/'):
-        return False, "Aplicação em arquivos de sistema proibida."
-    
-    if not os.access(target_file, os.W_OK):
-        return False, "Sem permissão de escrita no arquivo alvo."
-    
-    with open(patch_file, 'r') as f:
-        patch_content = f.read()
-    
-    is_valid, msg = validate_patch_content(patch_content)
-    if not is_valid:
-        return False, msg
-    
-    original_hash = compute_file_hash(target_file)
-    
+
+def validate_target_dir(target_dir):
+    if not os.path.exists(target_dir):
+        raise ValueError(f"Target directory {target_dir} does not exist.")
+    if not os.path.isdir(target_dir):
+        raise ValueError(f"{target_dir} is not a directory.")
+    if not os.access(target_dir, os.W_OK):
+        raise ValueError(f"Target directory {target_dir} is not writable.")
+
+
+def safe_apply_patch(patch_path, target_dir, strip=0):
+    validate_patch_file(patch_path)
+    validate_target_dir(target_dir)
+
+    # Change to target directory for safe patching
+    original_cwd = os.getcwd()
     try:
-        result = subprocess.run(['patch', '-p1', '--dry-run', target_file], 
-                                input=patch_content, text=True, capture_output=True)
+        os.chdir(target_dir)
+
+        # Run patch command with limited privileges and timeout
+        cmd = ['patch', '-p', str(strip), '--dry-run', '-i', os.path.basename(patch_path)]
+        # First, do a dry run to check for issues
+        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
         if result.returncode != 0:
-            return False, "Teste seco falhou: " + result.stderr
-        
-        # Aplicar de verdade
-        result = subprocess.run(['patch', '-p1', target_file], 
-                                input=patch_content, text=True, capture_output=True)
+            print(f"Dry run failed: {result.stderr}")
+            return False
+
+        # If dry run succeeds, apply the patch
+        cmd = ['patch', '-p', str(strip), '-i', os.path.basename(patch_path)]
+        result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
         if result.returncode == 0:
-            new_hash = compute_file_hash(target_file)
-            if new_hash == original_hash:
-                return False, "Patch não alterou o arquivo (possível falha)."
-            return True, "Patch aplicado com sucesso."
+            print("Patch applied successfully.")
+            return True
         else:
-            return False, "Falha ao aplicar patch: " + result.stderr
+            print(f"Patch application failed: {result.stderr}")
+            return False
+    finally:
+        os.chdir(original_cwd)
+
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(description="Safely apply patches with security checks.")
+    parser.add_argument("patch_file", help="Path to the patch file.")
+    parser.add_argument("-d", "--directory", default=".", help="Target directory (default: current).")
+    parser.add_argument("-p", "--strip", type=int, default=0, help="Strip level (default: 0).")
+
+    args = parser.parse_args()
+
+    try:
+        success = safe_apply_patch(args.patch_file, args.directory, args.strip)
+        sys.exit(0 if success else 1)
+    except ValueError as e:
+        print(f"Error: {e}", file=sys.stderr)
+        sys.exit(1)
+    except subprocess.TimeoutExpired:
+        print("Error: Patch application timed out.", file=sys.stderr)
+        sys.exit(1)
     except Exception as e:
-        return False, f"Erro durante aplicação: {str(e)}
-
- if __name__ == '__main__':
-    if len(sys.argv) != 3:
-        print("Uso: python patch.py <arquivo_alvo> <patch_file>")
+        print(f"Unexpected error: {e}", file=sys.stderr)
         sys.exit(1)
-    
-    target = sys.argv[1]
-    patch = sys.argv[2]
-    
-    success, msg = apply_secure_patch(target, patch)
-    print(msg)
-    sys.exit(0 if success else 1)
