--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -2,66 +2,78 @@
 import sys
 import os
 import subprocess
-import tempfile
-import difflib
+import hashlib
+import argparse
 
-# Security checks before applying any patch
-def security_check(patch_content, target_file):
-    # Check for dangerous commands or patterns in patch
-    dangerous_patterns = [
-        r'rm -rf',
-        r'dd if=',
-        r'chmod 777',
-        r'sudo',
-        r'exec',
-        r'eval'
-    ]
-    for pattern in dangerous_patterns:
-        if re.search(pattern, patch_content, re.IGNORECASE):
-            raise ValueError(f"Dangerous pattern detected: {pattern}")
+# Security checks
+def validate_patch_source(patch_file):
+    # Check if patch file exists and is readable
+    if not os.path.exists(patch_file):
+        raise ValueError(f"Patch file {patch_file} does not exist.")
+    if not os.access(patch_file, os.R_OK):
+        raise ValueError(f"Patch file {patch_file} is not readable.")
     
-    # Ensure target file is writable and not system file
-    if os.path.exists(target_file):
-        if not os.access(target_file, os.W_OK):
-            raise PermissionError(f"Cannot write to {target_file}")
-        if target_file.startswith('/etc/') or target_file.startswith('/bin/'):
-            raise ValueError(f"Cannot patch system file: {target_file}")
+    # Check file size to prevent huge files
+    size = os.path.getsize(patch_file)
+    if size > 10 * 1024 * 1024:  # 10MB limit
+        raise ValueError(f"Patch file {patch_file} too large: {size} bytes")
+    
+    # Compute hash for verification (example: compare to expected hash)
+    # In production, provide expected_hash as argument
+    expected_hash = None  # Placeholder: should be provided
+    if expected_hash:
+        with open(patch_file, 'rb') as f:
+            file_hash = hashlib.sha256(f.read()).hexdigest()
+            if file_hash != expected_hash:
+                raise ValueError(f"Patch hash mismatch for {patch_file}")
+    
+    # Basic content check: ensure it's a text file starting with diff
+    with open(patch_file, 'r') as f:
+        content = f.read(100)  # First 100 chars
+        if not content.startswith(('diff', 'Index:', '---')):
+            raise ValueError(f"Patch file {patch_file} does not appear to be a valid diff.")
     
     return True
 
-import re
+def apply_secure_patch(patch_file, target_dir, strip=0):
+    # Validate source first
+    validate_patch_source(patch_file)
+    
+    # Ensure target directory is safe (e.g., not system dirs)
+    if not os.path.isdir(target_dir):
+        raise ValueError(f"Target directory {target_dir} does not exist.")
+    if target_dir.startswith(('/etc', '/usr', '/var', '/boot', '/root')):
+        raise ValueError(f"Unsafe target directory: {target_dir}")
+    
+    # Run patch command with restrictions
+    cmd = ['patch', '-d', target_dir, '-p', str(strip), '--dry-run', patch_file]
+    try:
+        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
+        if 'hunk' in result.stdout or 'failed' in result.stdout.lower():
+            raise ValueError("Dry run failed: potential issues in patch.")
+    except subprocess.CalledProcessError as e:
+        raise ValueError(f"Dry run failed: {e}")
+    
+    # If dry-run passes, apply for real
+    cmd[-1] = '--no-backup'  # Avoid backups for security
+    cmd.remove('--dry-run')
+    subprocess.run(cmd, check=True)
+    print(f"Patch applied successfully to {target_dir}")
 
-def apply_patch(patch_file, target_file):
-    with open(patch_file, 'r') as f:
-        patch_content = f.read()
+if __name__ == '__main__':
+    parser = argparse.ArgumentParser(description='Apply patches with security checks')
+    parser.add_argument('patch_file', help='Path to the patch file')
+    parser.add_argument('-d', '--directory', default='.', help='Target directory')
+    parser.add_argument('-p', '--strip', type=int, default=0, help='Strip level')
+    parser.add_argument('--expected-hash', help='Expected SHA256 hash of patch')
     
-    if not security_check(patch_content, target_file):
-        return False
+    args = parser.parse_args()
     
-    # Proceed with patch application using subprocess
     try:
-        result = subprocess.run(['patch', '-p1', '--dry-run', target_file], input=patch_content, text=True, capture_output=True)
-        if result.returncode != 0:
-            print("Dry run failed, not applying.")
-            return False
-        
-        result = subprocess.run(['patch', '-p1', target_file], input=patch_content, text=True, capture_output=True)
-        if result.returncode == 0:
-            print("Patch applied successfully.")
-            return True
-        else:
-            print(f"Patch failed: {result.stderr}")
-            return False
+        apply_secure_patch(args.patch_file, args.directory, args.strip)
+    except ValueError as e:
+        print(f"Security check failed: {e}", file=sys.stderr)
+        sys.exit(1)
     except Exception as e:
-        print(f"Error applying patch: {e}")
-        return False
-
-if __name__ == "__main__":
-    if len(sys.argv) != 3:
-        print("Usage: python3 patch.py <patch_file> <target_file>")
-        sys.exit(1)
-    
-    patch_file = sys.argv[1]
-    target_file = sys.argv[2]
-    
-    apply_patch(patch_file, target_file)+        print(f"Error applying patch: {e}", file=sys.stderr)
+        sys.exit(1)