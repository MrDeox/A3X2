--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,59 +1,85 @@
 import sys
 import os
 import subprocess
+import re
 
 
-def validate_inputs(file_path, patch_path):
-    if not os.path.isfile(file_path):
-        raise ValueError(f"Target file '{file_path}' does not exist or is not a file.")
-    if not os.path.isfile(patch_path):
-        raise ValueError(f"Patch file '{patch_path}' does not exist or is not a file.")
-    # Additional security: Check if paths are within allowed directory
-    allowed_dir = os.getcwd()
-    if not (os.path.abspath(file_path).startswith(allowed_dir) and os.path.abspath(patch_path).startswith(allowed_dir)):
-        raise ValueError("Files must be within the current working directory for security.")
-    # Basic content validation for patch (e.g., starts with diff header)
-    with open(patch_path, 'r') as f:
-        content = f.read(100)  # Read first 100 chars
-        if not content.startswith(('diff', 'Index:', '---')):
-            raise ValueError("Patch file does not appear to be a valid diff.")
+def validate_patch_file(patch_file):
+    if not os.path.isfile(patch_file):
+        raise ValueError(f"Patch file '{patch_file}' does not exist or is not a file.")
+    
+    # Check for path traversal or absolute paths
+    abs_path = os.path.abspath(patch_file)
+    if '..' in patch_file or not abs_path.startswith(os.getcwd()):
+        raise ValueError("Patch file path appears to be invalid or attempts traversal.")
+    
+    # Basic size check to prevent huge/malicious files
+    if os.path.getsize(patch_file) > 10 * 1024 * 1024:  # 10MB limit
+        raise ValueError("Patch file too large, potential security risk.")
 
 
-def apply_patch_safely(file_path, patch_path):
-    try:
-        # Use subprocess with shell=False and list for security
-        cmd = ['patch', '-p1', file_path, '-i', patch_path, '--dry-run']
-        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
-        if result.returncode == 0:
-            print("Dry run successful. Applying patch...")
-            cmd = ['patch', '-p1', file_path, '-i', patch_path]
-            subprocess.run(cmd, check=True)
-            print("Patch applied successfully.")
-        else:
-            print("Patch would fail: ", result.stderr)
-            raise subprocess.CalledProcessError(result.returncode, cmd)
-    except subprocess.CalledProcessError as e:
-        print(f"Error applying patch: {e}")
-        sys.exit(1)
-    except Exception as e:
-        print(f"Unexpected error: {e}")
-        sys.exit(1)
+def scan_patch_content(patch_file):
+    with open(patch_file, 'r', encoding='utf-8', errors='ignore') as f:
+        content = f.read()
+    
+    # Simple regex checks for common dangerous patterns
+    dangerous_patterns = [
+        r'rm\s+-rf',
+        r'dd\s+if=',
+        r'chmod\s+777',
+        r';\s*(exec|system|eval)',
+        r'\$\(command\s+-v',
+        r'\b(root|sudo)\b'
+    ]
+    
+    for pattern in dangerous_patterns:
+        if re.search(pattern, content, re.IGNORECASE):
+            raise ValueError(f"Suspicious pattern '{pattern}' detected in patch.")
+    
+    # Check for non-standard file paths
+    if re.search(r'^\+\+\+\/(etc|home|root|var|tmp|\/)', content, re.MULTILINE):
+        raise ValueError("Patch attempts to modify sensitive system directories.")
 
 
-def main():
-    if len(sys.argv) != 3:
-        print("Usage: python patch.py <target_file> <patch_file>")
-        sys.exit(1)
+def apply_secure_patch(patch_file, strip_level=1):
+    try:
+        validate_patch_file(patch_file)
+        scan_patch_content(patch_file)
+        
+        # Ensure we're in a safe directory (not system dirs)
+        cwd = os.getcwd()
+        if any(sensitive in cwd for sensitive in ['/etc', '/var', '/usr', '/root', '/tmp']):
+            raise ValueError("Cannot apply patch in sensitive directory.")
+        
+        cmd = ['patch', '-p' + str(strip_level), '-i', patch_file, '--dry-run']
+        # First, dry run to check
+        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
+        if result.returncode != 0:
+            raise ValueError(f"Dry run failed: {result.stderr}")
+        
+        # If dry run passes, apply for real
+        cmd = ['patch', '-p' + str(strip_level), '-i', patch_file]
+        result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
+        
+        if result.returncode == 0:
+            print("Patch applied successfully.")
+            return 0
+        else:
+            print(f"Patch application failed: {result.stderr}")
+            return result.returncode
+            
+    except subprocess.TimeoutExpired:
+        print("Patch application timed out.")
+        return 1
+    except Exception as e:
+        print(f"Security check failed: {e}")
+        return 1
 
-    target_file = sys.argv[1]
-    patch_file = sys.argv[2]
-
-    try:
-        validate_inputs(target_file, patch_file)
-        apply_patch_safely(target_file, patch_file)
-    except ValueError as e:
-        print(f"Validation error: {e}")
-        sys.exit(1)
 
 if __name__ == '__main__':
-    main()
+    if len(sys.argv) != 2:
+        print("Usage: python patch.py <patch_file>")
+        sys.exit(1)
+    
+    patch_file = sys.argv[1]
+    sys.exit(apply_secure_patch(patch_file))
