--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,62 +1,113 @@
 import sys
 import subprocess
 import os
-import argparse
+import re
+from pathlib import Path
 
+class SecurePatchApplier:
+    def __init__(self):
+        self.target_dir = '.'
+        self.strip_level = 0
+        self.dry_run = False
+        self.verbose = False
 
-def validate_path(path):
-    """Validate that the path is safe and exists."""
-    if not os.path.exists(path):
-        raise ValueError(f"Path does not exist: {path}")
-    if not os.path.isfile(path):
-        raise ValueError(f"Path is not a file: {path}")
-    # Basic security: ensure it's not a symlink to sensitive areas (simplified)
-    if os.path.islink(path):
-        raise ValueError(f"Path is a symlink, not allowed for security: {path}")
-    return path
+    def parse_arguments(self, args):
+        i = 0
+        while i < len(args):
+            if args[i] == '-p' or args[i] == '--strip':
+                i += 1
+                if i < len(args):
+                    self.strip_level = int(args[i])
+                    i += 1
+            elif args[i] == '--dry-run':
+                self.dry_run = True
+                i += 1
+            elif args[i] == '-v' or args[i] == '--verbose':
+                self.verbose = True
+                i += 1
+            elif args[i].startswith('-'):
+                print(f"Unknown option: {args[i]}")
+                sys.exit(1)
+            else:
+                if not hasattr(self, 'patch_file'):
+                    self.patch_file = args[i]
+                    i += 1
+                else:
+                    self.target_dir = args[i]
+                    i += 1
+        if not hasattr(self, 'patch_file'):
+            print("Usage: python patch.py [options] <patchfile> [target_dir]")
+            sys.exit(1)
 
+    def validate_patch_file(self, patch_path):
+        if not os.path.exists(patch_path):
+            raise FileNotFoundError(f"Patch file not found: {patch_path}")
+        if not os.path.isfile(patch_path):
+            raise ValueError(f"Patch path is not a file: {patch_path}")
+        with open(patch_path, 'r') as f:
+            content = f.read()
+        if not re.search(r'^diff ', content, re.MULTILINE):
+            raise ValueError("Invalid patch format: No 'diff' lines found")
+        # Basic security: Check for suspicious commands (e.g., rm, exec)
+        suspicious_patterns = [r'\s*rm\s', r'\s*exec\s', r'\s*eval\s']
+        for pattern in suspicious_patterns:
+            if re.search(pattern, content, re.IGNORECASE):
+                raise ValueError(f"Potential security risk in patch: {pattern}")
+        if self.verbose:
+            print("Patch file validated successfully.")
 
-def validate_directory(dir_path):
-    """Validate target directory is safe."""
-    if not os.path.exists(dir_path):
-        os.makedirs(dir_path, exist_ok=True)
-    if not os.path.isdir(dir_path):
-        raise ValueError(f"Not a directory: {dir_path}")
-    # Security: ensure directory is within current working directory or specified safe root
-    abs_dir = os.path.abspath(dir_path)
-    abs_cwd = os.path.abspath(os.getcwd())
-    if not abs_dir.startswith(abs_cwd):
-        raise ValueError(f"Directory outside current working directory for security: {dir_path}")
-    return abs_dir
+    def find_target_files(self, patch_content):
+        # Extract file paths from diff headers
+        file_paths = re.findall(r'^---\s+(a/)?(.*)', patch_content, re.MULTILINE)
+        targets = []
+        for _, path in file_paths:
+            full_path = os.path.join(self.target_dir, path.lstrip('/'))
+            if os.path.exists(full_path):
+                targets.append(full_path)
+            else:
+                print(f"Warning: Target file does not exist: {full_path}")
+        return targets
 
+    def apply_patch(self):
+        try:
+            with open(self.patch_file, 'r') as f:
+                patch_content = f.read()
+            self.validate_patch_file(self.patch_file)
+            targets = self.find_target_files(patch_content)
+            if not targets:
+                print("No target files found.")
+                return
+            cmd = ['patch', '-p' + str(self.strip_level), '-i', self.patch_file, '-d', self.target_dir]
+            if self.dry_run:
+                cmd.append('--dry-run')
+            if self.verbose:
+                cmd.append('-v')
+            # Security: Use list for subprocess to avoid shell injection
+            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
+            if self.dry_run:
+                print("Dry run successful. No changes applied.")
+            else:
+                print("Patch applied successfully.")
+            if self.verbose:
+                print(result.stdout)
+        except subprocess.CalledProcessError as e:
+            print(f"Failed to apply patch: {e}")
+            print(e.stderr)
+            sys.exit(1)
+        except Exception as e:
+            print(f"Error: {e}")
+            sys.exit(1)
 
-def apply_patch(patch_file, target_dir=None, strip=1):
-    """Apply patch with security checks."""
-    patch_file = validate_path(patch_file)
-    if target_dir:
-        target_dir = validate_directory(target_dir)
-    
-    # Use subprocess with shell=False for security
-    cmd = ['patch', '-p', str(strip), '-i', patch_file]
-    if target_dir:
-        cmd.extend(['-d', target_dir])
-    
-    # Run with check=True to fail on error
-    result = subprocess.run(cmd, capture_output=True, text=True, check=True)
-    if result.returncode != 0:
-        raise RuntimeError(f"Patch failed: {result.stderr}")
-    print("Patch applied successfully.")
-
+    def backup_targets(self, targets):
+        for target in targets:
+            backup = target + '.bak'
+            if not os.path.exists(backup):
+                os.rename(target, backup)
+                print(f"Backup created: {backup}")
 
 if __name__ == '__main__':
-    parser = argparse.ArgumentParser(description='Secure patch applicator')
-    parser.add_argument('patch_file', help='Path to patch file')
-    parser.add_argument('-d', '--directory', help='Target directory')
-    parser.add_argument('-p', '--strip', type=int, default=1, help='Strip level')
-    
-    args = parser.parse_args()
-    try:
-        apply_patch(args.patch_file, args.directory, args.strip)
-    except Exception as e:
-        print(f"Error: {e}", file=sys.stderr)
-        sys.exit(1)
+    applier = SecurePatchApplier()
+    applier.parse_arguments(sys.argv[1:])
+    # Optional: Backup before applying
+    # applier.backup_targets(applier.find_target_files(open(applier.patch_file).read()))
+    applier.apply_patch()