--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -3,83 +3,63 @@
 import subprocess
 import re
 
+# Security checks
+def validate_path(path):
+    if not os.path.exists(path):
+        raise ValueError(f"Path does not exist: {path}")
+    if '..' in path or not os.path.abspath(path).startswith(os.getcwd()):
+        raise ValueError(f"Unsafe path detected: {path}")
+    return path
 
-def validate_patch_file(patch_file):
-    if not os.path.isfile(patch_file):
-        raise ValueError(f"Patch file '{patch_file}' does not exist or is not a file.")
+def validate_diff_content(diff):
+    # Check for dangerous commands like rm, del, etc.
+    dangerous_patterns = [r'rm\s', r'del\s', r'format\s', r'\bexec\b']
+    for pattern in dangerous_patterns:
+        if re.search(pattern, diff, re.IGNORECASE):
+            raise ValueError(f"Dangerous command detected in diff: {pattern}")
+    return diff
+
+def apply_patch_safely(patch_file, target_file):
+    target_file = validate_path(target_file)
+    with open(patch_file, 'r') as f:
+        diff_content = f.read()
+    validate_diff_content(diff_content)
     
-    # Check for path traversal or absolute paths
-    abs_path = os.path.abspath(patch_file)
-    if '..' in patch_file or not abs_path.startswith(os.getcwd()):
-        raise ValueError("Patch file path appears to be invalid or attempts traversal.")
+    # Backup original file
+    backup = target_file + '.backup'
+    if os.path.exists(backup):
+        os.remove(backup)
+    os.rename(target_file, backup)
     
-    # Basic size check to prevent huge/malicious files
-    if os.path.getsize(patch_file) > 10 * 1024 * 1024:  # 10MB limit
-        raise ValueError("Patch file too large, potential security risk.")
+    try:
+        result = subprocess.run(['patch', '-p1', '-i', patch_file, '--directory=' + os.path.dirname(target_file)], 
+                                capture_output=True, text=True, check=True)
+        if result.returncode != 0:
+            raise subprocess.CalledProcessError(result.returncode, 'patch', output=result.stdout + result.stderr)
+        print("Patch applied successfully.")
+    except subprocess.CalledProcessError as e:
+        print(f"Patch failed: {e}")
+        # Restore backup
+        os.rename(backup, target_file)
+        raise
+    except Exception as e:
+        print(f"Error: {e}")
+        # Restore backup
+        if os.path.exists(backup):
+            os.rename(backup, target_file)
+        raise
 
-
-def scan_patch_content(patch_file):
-    with open(patch_file, 'r', encoding='utf-8', errors='ignore') as f:
-        content = f.read()
-    
-    # Simple regex checks for common dangerous patterns
-    dangerous_patterns = [
-        r'rm\s+-rf',
-        r'dd\s+if=',
-        r'chmod\s+777',
-        r';\s*(exec|system|eval)',
-        r'\$\(command\s+-v',
-        r'\b(root|sudo)\b'
-    ]
-    
-    for pattern in dangerous_patterns:
-        if re.search(pattern, content, re.IGNORECASE):
-            raise ValueError(f"Suspicious pattern '{pattern}' detected in patch.")
-    
-    # Check for non-standard file paths
-    if re.search(r'^\+\+\+\/(etc|home|root|var|tmp|\/)', content, re.MULTILINE):
-        raise ValueError("Patch attempts to modify sensitive system directories.")
-
-
-def apply_secure_patch(patch_file, strip_level=1):
+if __name__ == "__main__":
+    if len(sys.argv) != 3:
+        print("Usage: python patch.py <patch_file> <target_file>")
+        sys.exit(1)
+    patch_file = sys.argv[1]
+    target_file = sys.argv[2]
     try:
-        validate_patch_file(patch_file)
-        scan_patch_content(patch_file)
-        
-        # Ensure we're in a safe directory (not system dirs)
-        cwd = os.getcwd()
-        if any(sensitive in cwd for sensitive in ['/etc', '/var', '/usr', '/root', '/tmp']):
-            raise ValueError("Cannot apply patch in sensitive directory.")
-        
-        cmd = ['patch', '-p' + str(strip_level), '-i', patch_file, '--dry-run']
-        # First, dry run to check
-        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
-        if result.returncode != 0:
-            raise ValueError(f"Dry run failed: {result.stderr}")
-        
-        # If dry run passes, apply for real
-        cmd = ['patch', '-p' + str(strip_level), '-i', patch_file]
-        result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
-        
-        if result.returncode == 0:
-            print("Patch applied successfully.")
-            return 0
-        else:
-            print(f"Patch application failed: {result.stderr}")
-            return result.returncode
-            
-    except subprocess.TimeoutExpired:
-        print("Patch application timed out.")
-        return 1
+        apply_patch_safely(patch_file, target_file)
+    except ValueError as e:
+        print(f"Security validation failed: {e}")
+        sys.exit(1)
     except Exception as e:
-        print(f"Security check failed: {e}")
-        return 1
-
-
-if __name__ == '__main__':
-    if len(sys.argv) != 2:
-        print("Usage: python patch.py <patch_file>")
+        print(f"Application failed: {e}")
         sys.exit(1)
-    
-    patch_file = sys.argv[1]
-    sys.exit(apply_secure_patch(patch_file))
