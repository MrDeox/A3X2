--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -2,95 +2,118 @@
 import sys
 import os
 import subprocess
+import tempfile
+import hashlib
 import re
 
+# Security configurations
+def is_safe_path(path):
+    """Check if path is safe (no directory traversal)."""
+    if '..' in path or path.startswith('/'):
+        return False
+    return True
+
 def validate_patch_content(patch_content):
-    # Security check: Scan for potentially dangerous patterns in patch
-    dangerous_patterns = [
-        r'\s*rm\s',  # rm commands
-        r'\s*del\s',  # del commands
-        r'\s*format\s',  # format commands
-        r'\s*exec\s',  # exec
-        r'\s*system\s',  # system calls
-        r'\s*#include\s*<stdio.h>',  # C includes that might be malicious
-        r'\s*os.system\s',  # Python os.system
+    """Basic validation of patch content for malicious patterns."""
+    malicious_patterns = [
+        r'rm\s+-rf',
+        r'dd\s+if=/dev/zero',
+        r'chmod\s+777',
+        r'exec\s+',
     ]
-    for pattern in dangerous_patterns:
+    for pattern in malicious_patterns:
         if re.search(pattern, patch_content, re.IGNORECASE):
-            return False, f"Dangerous pattern detected: {pattern}"
-    return True, "Safe"
+            return False
+    return True
 
-def apply_patch(patch_file, target_dir):
-    # Security check 1: Ensure patch_file exists and is readable
-    if not os.path.exists(patch_file):
-        print(f"Error: Patch file '{patch_file}' not found.")
-        return 1
-    if not os.access(patch_file, os.R_OK):
-        print(f"Error: Cannot read patch file '{patch_file}'.")
-        return 1
+def compute_file_hash(file_path):
+    """Compute SHA256 hash of a file."""
+    sha256_hash = hashlib.sha256()
+    with open(file_path, "rb") as f:
+        for byte_block in iter(lambda: f.read(4096), b""):
+            sha256_hash.update(byte_block)
+    return sha256_hash.hexdigest()
 
-    # Security check 2: Read and validate patch content
-    try:
-        with open(patch_file, 'r') as f:
-            patch_content = f.read()
-        is_safe, message = validate_patch_content(patch_content)
-        if not is_safe:
-            print(f"Security violation: {message}")
-            return 1
-        print(f"Patch validation: {message}")
-    except Exception as e:
-        print(f"Error reading patch: {e}")
-        return 1
-
-    # Security check 3: Ensure target_dir is within current working directory to prevent path traversal
-    abs_target = os.path.abspath(target_dir)
-    abs_cwd = os.path.abspath(os.getcwd())
-    if not abs_target.startswith(abs_cwd):
-        print(f"Error: Target directory '{target_dir}' is outside the current working directory for security reasons.")
-        return 1
-
-    # Security check 4: Check if target_dir exists and is writable
-    if not os.path.exists(target_dir):
-        print(f"Error: Target directory '{target_dir}' does not exist.")
-        return 1
-    if not os.access(target_dir, os.W_OK):
-        print(f"Error: Cannot write to target directory '{target_dir}'.")
-        return 1
-
-    # Apply the patch using subprocess for controlled execution
-    try:
-        cmd = ['patch', '-p1', '--dry-run', '-d', target_dir, '<', patch_file]
-        # First, do a dry run to test
-        result_dry = subprocess.run(cmd, capture_output=True, text=True)
-        if result_dry.returncode != 0:
-            print("Dry run failed - patch would not apply cleanly.")
-            print(result_dry.stderr)
-            return 1
-        print("Dry run successful.")
-
-        # Now apply for real
-        cmd = ['patch', '-p1', '-d', target_dir, '<', patch_file]
-        result = subprocess.run(cmd, capture_output=True, text=True)
-        if result.returncode != 0:
-            print("Patch application failed.")
-            print(result.stderr)
-            return 1
-        print("Patch applied successfully.")
-        return 0
-    except Exception as e:
-        print(f"Error during patch application: {e}")
-        return 1
-
-if __name__ == "__main__":
-    if len(sys.argv) != 3:
-        print("Usage: python patch.py <patch_file> <target_dir>")
-        print("Security features: Validates patch content, restricts target dir, dry-run test.")
+def main():
+    if len(sys.argv) < 3:
+        print("Usage: python patch.py <patch_file> <target_file>")
         sys.exit(1)
 
     patch_file = sys.argv[1]
-    target_dir = sys.argv[2]
+    target_file = sys.argv[2]
 
-    # Additional security: Log the action
-    print(f"Applying patch '{patch_file}' to '{target_dir}'...")
+    # Security Check 1: Validate patch file existence and readability
+    if not os.path.exists(patch_file):
+        print(f"Error: Patch file '{patch_file}' not found.")
+        sys.exit(1)
+    if not os.access(patch_file, os.R_OK):
+        print(f"Error: Cannot read patch file '{patch_file}'.")
+        sys.exit(1)
 
-    sys.exit(apply_patch(patch_file, target_dir))
+    # Security Check 2: Validate target file path safety
+    if not is_safe_path(os.path.basename(target_file)):
+        print(f"Error: Unsafe target path '{target_file}'.")
+        sys.exit(1)
+
+    # Security Check 3: Ensure target directory is writable
+    target_dir = os.path.dirname(target_file) or '.'
+    if not os.access(target_dir, os.W_OK):
+        print(f"Error: Cannot write to directory '{target_dir}'.")
+        sys.exit(1)
+
+    # Security Check 4: Validate patch content
+    with open(patch_file, 'r') as f:
+        patch_content = f.read()
+    if not validate_patch_content(patch_content):
+        print("Error: Patch contains potentially malicious content.")
+        sys.exit(1)
+
+    # Security Check 5: Backup original file if exists
+    if os.path.exists(target_file):
+        original_hash = compute_file_hash(target_file)
+        backup_file = target_file + ".backup"
+        os.rename(target_file, backup_file)
+        print(f"Backup created: {backup_file} (original hash: {original_hash})")
+
+    # Apply patch using subprocess with restricted environment
+    try:
+        # Create a temporary directory for safe patching
+        with tempfile.TemporaryDirectory() as temp_dir:
+            temp_target = os.path.join(temp_dir, os.path.basename(target_file))
+            # Copy patch to temp if needed, but apply directly
+            cmd = [
+                'patch',
+                '-p1',
+                '--directory=' + temp_dir,
+                '--input=' + patch_file,
+                '--output=' + temp_target
+            ]
+            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
+            print(f"Patch applied successfully in temp: {result.stdout}")
+
+            # Verify the patched file
+            new_hash = compute_file_hash(temp_target)
+            print(f"New file hash: {new_hash}")
+
+            # Move to target
+            os.rename(temp_target, target_file)
+            print(f"Patched file moved to: {target_file}")
+
+    except subprocess.CalledProcessError as e:
+        print(f"Error applying patch: {e.stderr}")
+        # Restore backup if exists
+        if os.path.exists(backup_file):
+            os.rename(backup_file, target_file)
+            print("Restored from backup.")
+        sys.exit(1)
+    except Exception as e:
+        print(f"Unexpected error: {e}")
+        if os.path.exists(backup_file):
+            os.rename(backup_file, target_file)
+            print("Restored from backup.")
+        sys.exit(1)
+
+    print("Patch application completed with security checks.")
+
+if __name__ == '__main__':
+    main()
