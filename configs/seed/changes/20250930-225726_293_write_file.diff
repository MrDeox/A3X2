--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,91 +1,56 @@
 import sys
 import os
 import subprocess
-import re
-import argparse
 
-class SecurePatchApplier:
-    def __init__(self):
-        self.target_file = None
-        self.patch_content = None
-        self.dry_run = False
 
-    def validate_target_file(self, target):
-        if not os.path.exists(target):
-            raise ValueError(f"Target file '{target}' does not exist.")
-        if not os.access(target, os.R_OK | os.W_OK):
-            raise PermissionError(f"No read/write access to '{target}'.")
-        # Avoid patching system files or outside current dir
-        if target.startswith('/') or '..' in target:
-            raise SecurityError(f"Patching '{target}' is not allowed for security reasons.")
-        self.target_file = target
+def apply_safe_patch(patch_file, target_dir='.'):
+    # Security check 1: Validate patch file existence and readability
+    if not os.path.exists(patch_file):
+        print(f"Error: Patch file '{patch_file}' not found.")
+        sys.exit(1)
+    if not os.access(patch_file, os.R_OK):
+        print(f"Error: Patch file '{patch_file}' is not readable.")
+        sys.exit(1)
 
-    def validate_patch_content(self, patch_str):
-        if not patch_str.strip():
-            raise ValueError("Patch content is empty.")
-        # Basic diff validation: check for unified diff format
-        if not re.search(r'^---\s+\S+', patch_str, re.MULTILINE):
-            raise ValueError("Invalid patch format: not a unified diff.")
-        # Check for dangerous commands (e.g., rm, chmod)
-        dangerous_patterns = [r'\b(rm|chmod|chown|sudo)\b', r';\s*']
-        for pattern in dangerous_patterns:
-            if re.search(pattern, patch_str, re.IGNORECASE):
-                raise SecurityError("Patch contains potentially dangerous operations.")
-        self.patch_content = patch_str
+    # Security check 2: Basic content validation to avoid dangerous patches
+    with open(patch_file, 'r') as f:
+        content = f.read()
+    dangerous_patterns = ['rm -rf', 'del /f', '; rm', 'chmod +x', '/dev/shm']
+    for pattern in dangerous_patterns:
+        if pattern in content.lower():
+            print(f"Error: Potentially dangerous content '{pattern}' detected in patch.")
+            sys.exit(1)
 
-    def apply(self, target, patch_str, dry_run=False):
-        try:
-            self.dry_run = dry_run
-            self.validate_target_file(target)
-            self.validate_patch_content(patch_str)
+    # Security check 3: Ensure target directory is safe (no system dirs)
+    if target_dir in ['/', '/etc', '/bin', '/usr', '/var', 'C:\\Windows']:
+        print(f"Error: Target directory '{target_dir}' is restricted for security.")
+        sys.exit(1)
 
-            if self.dry_run:
-                print("Dry run: Patch would be applied to", self.target_file)
-                print("Patch content:", self.patch_content)
-                return True
+    # Apply the patch using subprocess with limited privileges
+    try:
+        result = subprocess.run(
+            ['patch', '-p1', '-d', target_dir],
+            stdin=open(patch_file, 'r'),
+            capture_output=True,
+            text=True,
+            timeout=30  # Timeout to prevent hangs
+        )
+        if result.returncode != 0:
+            print(f"Patch failed: {result.stderr}")
+            sys.exit(1)
+        print("Patch applied successfully.")
+    except subprocess.TimeoutExpired:
+        print("Error: Patch application timed out.")
+        sys.exit(1)
+    except Exception as e:
+        print(f"Error applying patch: {e}")
+        sys.exit(1)
 
-            # Write patch to temp file securely
-            temp_patch = '/tmp/secure_patch_' + str(os.getpid()) + '.diff'
-            with open(temp_patch, 'w') as f:
-                f.write(self.patch_content)
-            os.chmod(temp_patch, 0o600)  # Secure permissions
 
-            # Use patch command with safe options
-            cmd = ['patch', '-p1', '--input=' + temp_patch, self.target_file]
-            if self.dry_run:
-                cmd.append('--dry-run')
-
-            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
-            if result.returncode == 0:
-                print("Patch applied successfully.")
-                return True
-            else:
-                print("Patch failed:", result.stderr)
-                return False
-        except subprocess.CalledProcessError as e:
-            print(f"Patch application failed: {e}")
-            return False
-        except (ValueError, PermissionError, SecurityError) as e:
-            print(f"Security validation failed: {e}")
-            return False
-        finally:
-            if 'temp_patch' in locals() and os.path.exists(temp_patch):
-                os.remove(temp_patch)
-
-    class SecurityError(Exception):
-        pass
-
-if __name__ == '__main__':
-    parser = argparse.ArgumentParser(description='Secure patch applicator')
-    parser.add_argument('target', help='Target file to patch')
-    parser.add_argument('patch_file', help='Patch file')
-    parser.add_argument('--dry-run', action='store_true', help='Dry run without applying')
-
-    args = parser.parse_args()
-
-    applier = SecurePatchApplier()
-    with open(args.patch_file, 'r') as f:
-        patch_content = f.read()
-
-    success = applier.apply(args.target, patch_content, args.dry_run)
-    sys.exit(0 if success else 1)
+if __name__ == "__main__":
+    if len(sys.argv) < 2:
+        print("Usage: python patch.py <patch_file> [target_dir]")
+        sys.exit(1)
+    patch_file = sys.argv[1]
+    target_dir = sys.argv[2] if len(sys.argv) > 2 else '.'
+    apply_safe_patch(patch_file, target_dir)
