--- a/agent.py
+++ b/agent.py
--- agent.py
+++ agent.py
@@ -1,76 +1,107 @@
-# Basic Agent Skeleton for Recursion Monitoring with Dynamic Metrics
-
+# Basic Agent for Dynamic Recursion Monitoring with Metrics Feedback
 import json
 import os
+import subprocess
+import sys
+from typing import Dict, Any, List
 
-class Agent:
-    def __init__(self, max_depth=10):
-        self.max_depth = max_depth
-        self.current_depth = 0
+class MetricsTracker:
+    def __init__(self):
         self.actions_total = 0
         self.actions_success = 0
-        self.success_rate = 1.0
-        self.metrics_history = []
-        self.auto_commit_threshold = 0.9
+        self.recursion_depth = 0
+        self.max_depth = 5
+        self.success_rate = 0.0
+        self.history: List[Dict[str, Any]] = []
 
-    def track_recursion(self):
-        self.current_depth += 1
-        if self.current_depth > 5:
-            self.adjust_depth()
-        return self.current_depth <= self.max_depth
-
-    def adjust_depth(self):
-        if self.success_rate < 0.8:
-            self.max_depth = max(1, self.max_depth - 1)
-            print(f"Adjusted max_depth to {self.max_depth} due to low success_rate {self.success_rate}")
-        elif self.success_rate > 0.95:
-            self.max_depth += 1
-            print(f"Increased max_depth to {self.max_depth} due to high success_rate {self.success_rate}")
-
-    def log_action(self, success=True):
+    def update_action(self, success: bool):
         self.actions_total += 1
         if success:
             self.actions_success += 1
-        self.success_rate = self.actions_success / self.actions_total if self.actions_total > 0 else 1.0
-        self.metrics_history.append({
-            'depth': self.current_depth,
-            'success_rate': self.success_rate,
-            'total_actions': self.actions_total
-        })
+        self.success_rate = self.actions_success / self.actions_total if self.actions_total > 0 else 0.0
+        self._adjust_depth()
 
-        if self.success_rate > self.auto_commit_threshold:
-            self.auto_commit()
+    def _adjust_depth(self):
+        if self.recursion_depth > self.max_depth and self.success_rate > 0.9:
+            self.max_depth += 1
+            print(f"Auto-adjusted max_depth to {self.max_depth} based on success_rate {self.success_rate:.2f}")
+        elif self.success_rate < 0.8 and self.max_depth > 5:
+            self.max_depth -= 1
+            print(f"Reduced max_depth to {self.max_depth} due to low success_rate {self.success_rate:.2f}")
 
-    def auto_commit(self):
-        # Simulate commit with tests
-        test_result = self.run_tests()
-        if test_result:
-            commit_msg = f"Auto-commit: success_rate {self.success_rate:.2f}, depth {self.current_depth}"
-            print(f"Committing changes: {commit_msg}")
-            # In real impl, use git commit
+    def log_action(self, action: str, obs: str, success: bool):
+        entry = {"action": action, "observation": obs, "success": success}
+        self.history.append(entry)
+        self.update_action(success)
+
+    def auto_commit_if_ready(self):
+        if self.success_rate > 0.9 and self.actions_total > 0:
+            try:
+                subprocess.run(["git", "add", "."], check=True, cwd="/home/arthur/Projetos/A3X")
+                subprocess.run(["git", "commit", "-m", f"Auto-commit: success_rate {self.success_rate:.2f}, actions {self.actions_total}"], check=True, cwd="/home/arthur/Projetos/A3X")
+                print("Auto-commit successful")
+            except subprocess.CalledProcessError:
+                print("Auto-commit failed")
+
+class Agent:
+    def __init__(self):
+        self.metrics = MetricsTracker()
+        self.max_recursion = 10  # Initial limit
+        self.current_depth = 0
+
+    def execute(self, objective: str, iteration: int, history: List[Dict] = None):
+        if history:
+            # Parse history to update metrics
+            for entry in history:
+                if "ACTION" in entry and "OBS" in entry:
+                    action = entry["ACTION"]
+                    obs = entry["OBS"]
+                    success = "OK" in obs or "concluÃ­do" in obs
+                    self.metrics.log_action(action, obs, success)
+        self.current_depth += 1
+        if self.current_depth > self.max_recursion:
+            print("Max recursion exceeded")
+            return {"type": "finish", "text": "Recursion limit reached"}
+
+        # Decide next action based on objective
+        if iteration == 1:
+            # Initial setup
+            return self._read_file("/home/arthur/Projetos/A3X/configs/agent.py")
+        elif "implementar monitoramento" in objective.lower():
+            # Add monitoring logic
+            return self._write_monitoring_code()
         else:
-            print("Tests failed, skipping commit")
+            # Generic action
+            return {"type": "message", "text": f"Processing iteration {iteration} with depth {self.current_depth}"}
+
+    def _read_file(self, path: str) -> Dict[str, Any]:
+        try:
+            with open(path, 'r') as f:
+                content = f.read()
+            self.metrics.log_action(f"READ_FILE {path}", "OK", True)
+            return {"type": "read_file", "path": path, "content": content}
+        except FileNotFoundError:
+            self.metrics.log_action(f"READ_FILE {path}", "FAIL (File not found)", False)
+            return {"type": "write_file", "path": path, "content": "# Initial skeleton\nclass Agent:\n    pass"}
+
+    def _write_monitoring_code(self) -> Dict[str, Any]:
+        content = '''# Full implementation with dynamic monitoring
+import json  # ... (previous code + new features)'''
+        # Simulate writing enhanced code
+        return {"type": "write_file", "path": "/home/arthur/Projetos/A3X/configs/agent.py", "content": content}
 
     def run_tests(self):
-        # Placeholder for tests
-        return True  # Assume success for now
+        # Simple test for metrics
+        test_success = self.metrics.success_rate > 0.9
+        print(f"Test: success_rate check - {test_success}")
+        self.metrics.auto_commit_if_ready()
+        return test_success
 
-    def get_metrics(self):
-        return {
-            'current_depth': self.current_depth,
-            'max_depth': self.max_depth,
-            'success_rate': self.success_rate,
-            'actions_total': self.actions_total,
-            'history_length': len(self.metrics_history)
-        }
-
-# Example usage
+# Usage example
 if __name__ == "__main__":
     agent = Agent()
-    for i in range(10):
-        if agent.track_recursion():
-            agent.log_action(success=(i % 3 != 0))  # Simulate some failures
-        else:
-            print("Recursion depth exceeded")
-            break
-    print(json.dumps(agent.get_metrics(), indent=2))
+    # Simulate execution
+    for i in range(1, 11):
+        result = agent.execute("Implement monitoring", i)
+        print(result)
+    agent.run_tests()