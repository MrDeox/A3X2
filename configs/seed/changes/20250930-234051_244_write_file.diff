--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -2,37 +2,95 @@
 import sys
 import os
 import subprocess
-import re
+import tempfile
 
-# Security checks
-def validate_patch_file(patch_path):
-    if not os.path.exists(patch_path):
-        raise FileNotFoundError(f"Patch file not found: {patch_path}")
-    with open(patch_path, 'r') as f:
-        content = f.read()
-    # Check for dangerous patterns, e.g., modifying system files
-    dangerous_patterns = [r'/etc/', r'/bin/', r'/usr/']
+
+def validate_patch_safety(patch_content):
+    """Basic safety checks for patch content."""
+    dangerous_patterns = [
+        r'rm\s+-rf',
+        r'exec\s+',
+        r'sudo\s+',
+        r'chmod\s+777',
+        r'dd\s+if=/dev/zero'
+    ]
     for pattern in dangerous_patterns:
-        if re.search(pattern, content, re.IGNORECASE):
-            raise ValueError(f"Potential security risk: patch targets {pattern}")
-    return True
+        if re.search(pattern, patch_content, re.IGNORECASE):
+            return False, f"Dangerous pattern detected: {pattern}"
+    return True, "Safe"
 
-def apply_patch_safely(patch_path, target_dir='.'):
+
+def apply_patch_safely(patch_diff, target_file):
+    """Apply patch with safety checks."""
+    if not os.path.exists(target_file):
+        return False, "Target file does not exist."
+    
+    # Check permissions: ensure we own the file or have write access
+    if not os.access(target_file, os.W_OK):
+        return False, "No write access to target file."
+    
+    safe, msg = validate_patch_safety(patch_diff)
+    if not safe:
+        return False, msg
+    
+    # Use temporary file for patch
+    with tempfile.NamedTemporaryFile(mode='w', suffix='.patch', delete=False) as temp_patch:
+        temp_patch.write(patch_diff)
+        temp_patch_path = temp_patch.name
+    
     try:
-        validate_patch_file(patch_path)
-        cmd = ['patch', '-p1', '-d', target_dir, '-i', patch_path]
-        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
+        # Run patch command with limited environment
+        env = os.environ.copy()
+        env['PATH'] = '/usr/bin:/bin'  # Restrict PATH
+        result = subprocess.run(
+            ['patch', '-p1', '--dry-run', target_file],
+            input=patch_diff.encode(),
+            capture_output=True,
+            text=True,
+            env=env,
+            timeout=30  # Timeout to prevent hangs
+        )
+        if result.returncode != 0:
+            return False, f"Dry run failed: {result.stderr}"
+        
+        # If dry run passes, apply
+        result = subprocess.run(
+            ['patch', '-p1', target_file],
+            input=patch_diff.encode(),
+            capture_output=True,
+            text=True,
+            env=env,
+            timeout=30
+        )
         if result.returncode == 0:
-            print("Patch applied successfully.")
+            return True, "Patch applied successfully."
         else:
-            print(f"Patch failed: {result.stderr}")
+            return False, f"Patch application failed: {result.stderr}"
+    except subprocess.TimeoutExpired:
+        return False, "Patch application timed out."
     except Exception as e:
-        print(f"Error applying patch: {e}")
+        return False, f"Error: {str(e)}"
+    finally:
+        if os.path.exists(temp_patch_path):
+            os.unlink(temp_patch_path)
+
+
+if __name__ == '__main__':
+    if len(sys.argv) < 2:
+        print("Usage: python patch.py <target_file> <patch_file>")
         sys.exit(1)
+    
+    target = sys.argv[1]
+    patch_file = sys.argv[2] if len(sys.argv) > 2 else None
+    
+    if patch_file and os.path.exists(patch_file):
+        with open(patch_file, 'r') as f:
+            patch_content = f.read()
+    else:
+        patch_content = sys.stdin.read()
+    
+    success, message = apply_patch_safely(patch_content, target)
+    print(message)
+    sys.exit(0 if success else 1)
 
-if __name__ == "__main__":
-    if len(sys.argv) < 2:
-        print("Usage: python patch.py <patch_file>")
-        sys.exit(1)
-    patch_file = sys.argv[1]
-    apply_patch_safely(patch_file)
+import re  # Add this import for regex in validate_patch_safety