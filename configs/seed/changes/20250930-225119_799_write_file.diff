--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,40 +1,62 @@
 import sys
 import os
 import subprocess
+import argparse
 
-# Verificações de segurança básicas
-if len(sys.argv) < 2:
-    print("Uso: python patch.py <arquivo_patch> [arquivo_alvo]")
-    sys.exit(1)
 
-patchfile = sys.argv[1]
-if not os.path.exists(patchfile):
-    print("Erro: Arquivo de patch não encontrado: " + patchfile)
-    sys.exit(1)
+def sanitize_path(path):
+    """Sanitize path to prevent directory traversal."""
+    if '..' in path or '/' in path.split(os.sep)[0]:
+        raise ValueError("Invalid path: directory traversal detected")
+    return os.path.abspath(os.path.expanduser(path))
 
-# Verificar se o patch não é malicioso (exemplo simples: tamanho limite)
-if os.path.getsize(patchfile) > 1024 * 1024:  # 1MB limite
-    print("Erro: Patch muito grande, possível risco de segurança.")
-    sys.exit(1)
 
-if len(sys.argv) > 2:
-    target = sys.argv[2]
-    if not os.path.exists(target):
-        print("Aviso: Arquivo alvo não encontrado: " + target)
-        # Não falhar, deixar patch decidir
-    cmd = ['patch', '-i', patchfile, target]
-else:
-    cmd = ['patch', '-i', patchfile]
+def validate_file_exists(path, mode='r'):
+    """Check if file exists and has appropriate permissions."""
+    if not os.path.exists(path):
+        raise FileNotFoundError(f"File does not exist: {path}")
+    if mode == 'r' and not os.access(path, os.R_OK):
+        raise PermissionError(f"No read permission for: {path}")
+    if mode == 'w' and not os.access(path, os.W_OK):
+        raise PermissionError(f"No write permission for: {path}")
 
-# Executar com verificação de retorno
-try:
-    result = subprocess.run(cmd, capture_output=True, text=True, check=True)
-    print("Patch aplicado com sucesso.")
-    print(result.stdout)
-except subprocess.CalledProcessError as e:
-    print("Falha ao aplicar patch:")
-    print(e.stderr)
-    sys.exit(1)
-except FileNotFoundError:
-    print("Erro: Comando 'patch' não encontrado no sistema.")
-    sys.exit(1)
+
+def apply_patch(patch_file, target_file, strip=0):
+    """Apply patch securely using subprocess."""
+    # Sanitize paths
+    patch_file = sanitize_path(patch_file)
+    target_file = sanitize_path(target_file)
+    
+    # Validate files
+    validate_file_exists(patch_file, 'r')
+    if os.path.exists(target_file):
+        validate_file_exists(target_file, 'r')
+    
+    # Use subprocess with shell=False to avoid injection
+    cmd = ['patch', f'--strip={strip}', target_file, '-i', patch_file]
+    
+    try:
+        result = subprocess.run(cmd, check=True, capture_output=True, text=True)
+        print("Patch applied successfully.")
+        print(result.stdout)
+    except subprocess.CalledProcessError as e:
+        print(f"Patch failed: {e}")
+        print(e.stderr)
+        raise
+    except FileNotFoundError:
+        raise RuntimeError("'patch' command not found. Ensure it's installed.")
+
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(description="Secure patch applicator")
+    parser.add_argument('patch_file', help="Path to patch file")
+    parser.add_argument('target_file', help="Path to target file")
+    parser.add_argument('--strip', type=int, default=0, help="Strip level for patch")
+    
+    args = parser.parse_args()
+    
+    try:
+        apply_patch(args.patch_file, args.target_file, args.strip)
+    except Exception as e:
+        print(f"Error: {e}", file=sys.stderr)
+        sys.exit(1)
