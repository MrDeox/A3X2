--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,84 +1,73 @@
 #!/usr/bin/env python3
 import sys
 import os
+import re
 import subprocess
-import tempfile
-import shutil
-import hashlib
-import re
 
-# Security checks
-def validate_patch_content(patch_content):
-    # Check for dangerous patterns like exec, eval, system calls
+# Security checks for patch application
+def validate_patch_safety(diff_content):
+    # Check for dangerous commands
     dangerous_patterns = [
-        r'eval\(', r'exec\(', r'__import__\(', r'subprocess\.', r'os\.(system|pop en|popen)',
-        r'open\(', r'file\(', r'\$\(',
+        r'rm\s+-rf',
+        r'del\s+/f\s+/q',
+        r'format\s+c:',
+        r'exec\s+',
+        r'eval\s*\(',
+        r'__import__\s*\(\s*"os"',
+        r'open\s*\(\s*"/etc/passwd"',
     ]
     for pattern in dangerous_patterns:
-        if re.search(pattern, patch_content, re.IGNORECASE):
+        if re.search(pattern, diff_content, re.IGNORECASE):
             return False, f"Dangerous pattern detected: {pattern}"
-    # Check patch size limit
-    if len(patch_content) > 10000:  # Arbitrary limit
-        return False, "Patch too large"
-    return True, "Valid"
+    
+    # Check file paths for sensitive locations
+    sensitive_paths = [
+        '/etc/',
+        '/root/',
+        '/var/log/',
+        '/proc/',
+        '/sys/',
+    ]
+    for path in sensitive_paths:
+        if path in diff_content:
+            return False, f"Sensitive path detected: {path}"
+    
+    # Ensure no arbitrary code execution
+    if 'python -c' in diff_content or 'bash -c' in diff_content:
+        return False, "Arbitrary code execution detected"
+    
+    return True, "Patch is safe"
 
-def compute_hash(content):
-    return hashlib.sha256(content.encode()).hexdigest()
-
-def safe_apply_patch(patch_file, target_file):
-    # Validate target file exists and is writable
-    if not os.path.exists(target_file):
-        raise ValueError(f"Target file {target_file} does not exist")
-    if not os.access(target_file, os.W_OK):
-        raise ValueError(f"Target file {target_file} is not writable")
-
-    with open(patch_file, 'r') as f:
-        patch_content = f.read()
-
-    is_valid, msg = validate_patch_content(patch_content)
-    if not is_valid:
-        raise ValueError(msg)
-
-    # Backup original
-    original_hash = compute_hash(open(target_file).read())
-    backup_file = target_file + '.backup.' + original_hash[:8]
-    shutil.copy2(target_file, backup_file)
-
-    # Apply patch safely
-    try:
-        result = subprocess.run(['patch', '-p1', '--backup', '--verbose', target_file], 
-                                input=patch_content.encode(), 
-                                capture_output=True, check=True)
-        print(f"Patch applied successfully: {result.stdout.decode()}")
-        return True
-    except subprocess.CalledProcessError as e:
-        print(f"Patch failed: {e.stderr.decode()}")
-        # Restore backup
-        shutil.copy2(backup_file, target_file)
-        return False
-    except Exception as e:
-        print(f"Unexpected error: {e}")
-        shutil.copy2(backup_file, target_file)
-        return False
+def apply_secure_patch(diff_file=None, target_dir=None):
+    if diff_file is None:
+        diff_content = sys.stdin.read()
+    else:
+        with open(diff_file, 'r') as f:
+            diff_content = f.read()
+    
+    # Security validation
+    is_safe, message = validate_patch_safety(diff_content)
+    if not is_safe:
+        print(f"SECURITY ERROR: {message}")
+        sys.exit(1)
+    
+    print(f"Security check passed: {message}")
+    
+    # Set target directory if provided
+    cmd = ['patch', '-p1']
+    if target_dir:
+        cmd.extend(['-d', target_dir])
+    
+    # Apply patch
+    result = subprocess.run(cmd, input=diff_content, text=True, capture_output=True)
+    if result.returncode != 0:
+        print(f"Patch failed: {result.stderr.decode()}")
+        sys.exit(1)
+    
+    print("Patch applied successfully.")
 
 if __name__ == '__main__':
-    if len(sys.argv) != 3:
-        print("Usage: python3 patch.py <patch_file> <target_file>")
-        sys.exit(1)
-
-    patch_file = sys.argv[1]
-    target_file = sys.argv[2]
-
-    if not os.path.exists(patch_file):
-        print(f"Patch file {patch_file} does not exist")
-        sys.exit(1)
-
-    try:
-        success = safe_apply_patch(patch_file, target_file)
-        sys.exit(0 if success else 1)
-    except ValueError as e:
-        print(f"Security validation failed: {e}")
-        sys.exit(1)
-    except Exception as e:
-        print(f"Error: {e}")
-        sys.exit(1)
+    if len(sys.argv) > 1:
+        apply_secure_patch(sys.argv[1])
+    else:
+        apply_secure_patch()