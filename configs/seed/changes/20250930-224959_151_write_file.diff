--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,120 +1,86 @@
 import sys
 import os
 import subprocess
-import re
-from pathlib import Path
+import shutil
 
-class SecurePatchApplier:
-    def __init__(self):
-        self.target_dir = '.'
-        self.strip_level = 0
-        self.dry_run = False
-        self.backup = True
+def apply_patch(patch_file, target_file):
+    # Security check: Ensure target file exists
+    if not os.path.exists(target_file):
+        print(f"Security check failed: Target file '{target_file}' does not exist.")
+        return False
+    
+    # Security check: Ensure patch file exists and is readable
+    if not os.path.exists(patch_file):
+        print(f"Security check failed: Patch file '{patch_file}' does not exist.")
+        return False
+    
+    # Create backup before applying
+    backup_file = target_file + '.backup'
+    try:
+        shutil.copy2(target_file, backup_file)
+        print(f"Backup created: {backup_file}")
+    except Exception as e:
+        print(f"Failed to create backup: {e}")
+        return False
+    
+    # Dry-run to test the patch without applying
+    try:
+        dry_run_result = subprocess.run(
+            ['patch', '--dry-run', '-p1', '-i', patch_file],
+            capture_output=True,
+            text=True,
+            check=False
+        )
+        if dry_run_result.returncode != 0:
+            print(f"Dry-run failed: {dry_run_result.stderr}")
+            # Restore backup (though not modified)
+            return False
+    except FileNotFoundError:
+        print("Error: 'patch' command not found. Ensure it's installed.")
+        return False
+    except Exception as e:
+        print(f"Unexpected error during dry-run: {e}")
+        return False
+    
+    # Apply the patch
+    try:
+        apply_result = subprocess.run(
+            ['patch', '-p1', '-i', patch_file],
+            capture_output=True,
+            text=True,
+            check=True
+        )
+        print("Patch applied successfully.")
+        # Optionally remove backup on success
+        # os.remove(backup_file)
+        return True
+    except subprocess.CalledProcessError as e:
+        print(f"Patch application failed: {e.stderr}")
+        # Restore from backup on failure
+        try:
+            os.replace(backup_file, target_file)
+            print(f"Restored from backup: {target_file}")
+        except Exception as restore_e:
+            print(f"Failed to restore backup: {restore_e}")
+        return False
+    except Exception as e:
+        print(f"Unexpected error during patch application: {e}")
+        # Attempt restore
+        try:
+            os.replace(backup_file, target_file)
+            print(f"Restored from backup: {target_file}")
+        except Exception as restore_e:
+            print(f"Failed to restore backup: {restore_e}")
+        return False
 
-    def parse_arguments(self, args):
-        # Simple argument parsing for demo
-        for arg in args:
-            if arg.startswith('--target='):
-                self.target_dir = arg.split('=', 1)[1]
-            elif arg.startswith('--strip='):
-                self.strip_level = int(arg.split('=', 1)[1])
-            elif arg == '--dry-run':
-                self.dry_run = True
-            elif arg == '--no-backup':
-                self.backup = False
-
-    def validate_target_dir(self, target_dir):
-        if not os.path.isdir(target_dir):
-            raise ValueError(f"Target directory '{target_dir}' does not exist.")
-        # Security check: avoid system directories
-        abs_path = os.path.abspath(target_dir)
-        forbidden = ['/etc', '/usr', '/var', '/boot', '/root']
-        if any(abs_path.startswith(f) for f in forbidden):
-            raise ValueError(f"Cannot patch in system directory: {abs_path}")
-        return abs_path
-
-    def validate_diff_content(self, diff_content):
-        # Basic validation: check if it's a valid unified diff
-        if not re.search(r'^\+{3} ', diff_content, re.MULTILINE):
-            raise ValueError("Invalid diff format: missing +++ header")
-        if not re.search(r'^\-{3} ', diff_content, re.MULTILINE):
-            raise ValueError("Invalid diff format: missing --- header")
-        # Check for potentially dangerous commands (e.g., shell injection if any)
-        if re.search(r'[;&|`$]', diff_content):
-            raise ValueError("Diff contains potentially dangerous characters")
-        return True
-
-    def extract_target_files(self, diff_content):
-        # Extract potential target files from diff headers
-        targets = set()
-        for line in diff_content.splitlines():
-            if line.startswith('--- '):
-                path = line[4:].strip()
-                if path and not path.startswith('/dev/'):
-                    targets.add(path)
-        return list(targets)
-
-    def check_file_permissions(self, target_files):
-        for file_path in target_files:
-            abs_path = os.path.join(self.target_dir, file_path.lstrip('/'))
-            if os.path.exists(abs_path):
-                if not os.access(abs_path, os.W_OK):
-                    raise PermissionError(f"No write permission for {abs_path}")
-            # Ensure not patching executables without confirmation (simplified)
-            if os.path.isfile(abs_path) and os.access(abs_path, os.X_OK):
-                print(f"Warning: {abs_path} is executable. Proceed with caution.")
-
-    def apply_patch(self, diff_path=None, diff_content=None):
-        if diff_path:
-            with open(diff_path, 'r') as f:
-                diff_content = f.read()
-        elif not diff_content:
-            raise ValueError("Provide either diff_path or diff_content")
-
-        self.validate_diff_content(diff_content)
-        target_files = self.extract_target_files(diff_content)
-        self.check_file_permissions(target_files)
-        validated_dir = self.validate_target_dir(self.target_dir)
-
-        # Prepare patch command with safety options
-        cmd = ['patch', '-d', validated_dir, '-p' + str(self.strip_level)]
-        if self.dry_run:
-            cmd.append('--dry-run')
-        if self.backup:
-            cmd.append('-b')
-        cmd.extend(['--reject-file=-', '--forward', '--batch'])
-
-        # Security: Use stdin for diff to avoid file-based injection
-        try:
-            if self.dry_run:
-                print("Dry run mode: Not applying patch.")
-                result = subprocess.run(cmd, input=diff_content.encode(), capture_output=True, text=True)
-            else:
-                with subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True) as proc:
-                    stdout, stderr = proc.communicate(input=diff_content)
-                result = subprocess.CompletedProcess(cmd, proc.returncode, stdout, stderr)
-
-            if result.returncode != 0:
-                raise RuntimeError(f"Patch failed: {result.stderr}")
-            print("Patch applied successfully.")
-            return True
-        except subprocess.SubprocessError as e:
-            raise RuntimeError(f"Error executing patch: {e}")
-
-    def run(self, args):
-        self.parse_arguments(args[1:] if args else [])
-        # For demo, assume diff from stdin or file
-        diff_input = sys.stdin.read().strip()
-        if not diff_input:
-            print("No diff provided. Usage: python patch.py [--target=DIR] [--strip=N] < diff.patch")
-            return 1
-        try:
-            self.apply_patch(diff_content=diff_input)
-            return 0
-        except Exception as e:
-            print(f"Error: {e}", file=sys.stderr)
-            return 1
-
-if __name__ == '__main__':
-    applier = SecurePatchApplier()
-    sys.exit(applier.run(sys.argv))
+if __name__ == "__main__":
+    if len(sys.argv) != 3:
+        print("Usage: python patch.py <patch_file> <target_file>")
+        print("Security note: This script includes checks for file existence, backups, and dry-runs.")
+        sys.exit(1)
+    
+    patch_file = sys.argv[1]
+    target_file = sys.argv[2]
+    
+    success = apply_patch(patch_file, target_file)
+    sys.exit(0 if success else 1)
