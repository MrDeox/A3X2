--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,53 +1,103 @@
 #!/usr/bin/env python3
 import sys
 import os
+import shutil
+import tempfile
 import subprocess
 
-def safety_check_patch(patch_content):
-    # Basic safety check: ensure patch doesn't contain dangerous commands
-    dangerous_patterns = ['rm -rf', 'exec', 'eval', 'os.system']
-    for pattern in dangerous_patterns:
-        if pattern in patch_content:
-            print(f"Security warning: Potential dangerous pattern '{pattern}' detected.")
-            return False
-    return True
-
-def apply_patch(patch_file, target_file):
+def apply_patch(patch_content, target_file):
+    # Security check 1: Ensure target file exists and is a regular file
     if not os.path.exists(target_file):
         print(f"Error: Target file {target_file} does not exist.")
-        return 1
-    
-    if not os.path.exists(patch_file):
-        print(f"Error: Patch file {patch_file} does not exist.")
-        return 1
-    
-    with open(patch_file, 'r') as f:
-        patch_content = f.read()
-    
-    if not safety_check_patch(patch_content):
-        response = input("Continue despite security warning? (y/n): ")
-        if response.lower() != 'y':
-            return 1
-    
-    # Confirm application
-    response = input(f"Apply patch to {target_file}? (y/n): ")
-    if response.lower() != 'y':
-        return 0
-    
+        sys.exit(1)
+    if not os.path.isfile(target_file):
+        print(f"Error: {target_file} is not a regular file.")
+        sys.exit(1)
+
+    # Security check 2: Check write permissions
+    if not os.access(target_file, os.W_OK):
+        print(f"Error: No write permission for {target_file}.")
+        sys.exit(1)
+
+    # Security check 3: Create backup of original file
+    backup_file = target_file + ".backup"
     try:
-        cmd = ['patch', '-p1', '<', patch_file, target_file]
-        result = subprocess.run(['patch', target_file, patch_file], capture_output=True, text=True)
+        shutil.copy2(target_file, backup_file)
+        print(f"Backup created: {backup_file}")
+    except Exception as e:
+        print(f"Error creating backup: {e}")
+        sys.exit(1)
+
+    # Security check 4: Basic validation of patch content
+    if not patch_content.strip().startswith(('diff --git', '--- ')):
+        print("Error: Invalid patch format. Patch must start with 'diff' or '---'.")
+        sys.exit(1)
+
+    # Security check 5: Limit patch size to prevent large inputs
+    if len(patch_content) > 100000:  # 100KB limit
+        print("Error: Patch too large.")
+        sys.exit(1)
+
+    # Apply the patch using subprocess in a controlled manner
+    with tempfile.NamedTemporaryFile(mode='w', suffix='.patch', delete=False) as f:
+        f.write(patch_content)
+        temp_patch = f.name
+
+    try:
+        # Run patch command with limited environment
+        env = os.environ.copy()
+        env['PATH'] = '/usr/bin:/bin'  # Restrict PATH
+        result = subprocess.run(
+            ['patch', '-p1', target_file],
+            input=patch_content,
+            capture_output=True,
+            text=True,
+            env=env,
+            timeout=30  # Timeout to prevent hangs
+        )
         if result.returncode != 0:
-            print(f"Patch failed: {result.stderr}")
-            return 1
-        print("Patch applied successfully.")
-        return 0
+            print("Patch application failed:")
+            print(result.stderr)
+            # Restore backup on failure
+            shutil.copy2(backup_file, target_file)
+            print("Restored from backup.")
+            sys.exit(1)
+        else:
+            print("Patch applied successfully.")
+            os.chmod(target_file, 0o644)  # Set safe permissions
+    except subprocess.TimeoutExpired:
+        print("Patch application timed out.")
+        shutil.copy2(backup_file, target_file)
+        sys.exit(1)
     except Exception as e:
         print(f"Error applying patch: {e}")
-        return 1
+        shutil.copy2(backup_file, target_file)
+        sys.exit(1)
+    finally:
+        if os.path.exists(temp_patch):
+            os.unlink(temp_patch)
+        if os.path.exists(backup_file):
+            # Optionally keep backup, or remove after success
+            pass  # Keep for now
 
 if __name__ == "__main__":
     if len(sys.argv) != 3:
-        print("Usage: python patch.py <patch_file> <target_file>")
+        print("Usage: python patch.py <target_file> <patch_file>")
         sys.exit(1)
-    sys.exit(apply_patch(sys.argv[1], sys.argv[2]))+
+    target_file = sys.argv[1]
+    patch_file = sys.argv[2]
+
+    # Security check 6: Validate patch file
+    if not os.path.exists(patch_file):
+        print(f"Error: Patch file {patch_file} does not exist.")
+        sys.exit(1)
+
+    try:
+        with open(patch_file, 'r') as f:
+            patch_content = f.read()
+    except Exception as e:
+        print(f"Error reading patch file: {e}")
+        sys.exit(1)
+
+    apply_patch(patch_content, target_file)
