--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -2,118 +2,43 @@
 import sys
 import os
 import subprocess
-import tempfile
-import hashlib
 import re
 
-# Security configurations
-def is_safe_path(path):
-    """Check if path is safe (no directory traversal)."""
-    if '..' in path or path.startswith('/'):
-        return False
+# Security checks
+def validate_patch_file(patch_path):
+    if not os.path.exists(patch_path):
+        raise FileNotFoundError(f"Patch file not found: {patch_path}")
+    if not os.access(patch_path, os.R_OK):
+        raise PermissionError(f"Patch file not readable: {patch_path}")
+    # Basic check for malicious content (e.g., no exec or dangerous commands)
+    with open(patch_path, 'r') as f:
+        content = f.read()
+    dangerous_patterns = [r'\b(exec|eval|open\([^)]*w)\b', r'rm -rf']
+    for pattern in dangerous_patterns:
+        if re.search(pattern, content, re.IGNORECASE):
+            raise ValueError(f"Potential malicious content detected in patch: {pattern}")
     return True
 
-def validate_patch_content(patch_content):
-    """Basic validation of patch content for malicious patterns."""
-    malicious_patterns = [
-        r'rm\s+-rf',
-        r'dd\s+if=/dev/zero',
-        r'chmod\s+777',
-        r'exec\s+',
-    ]
-    for pattern in malicious_patterns:
-        if re.search(pattern, patch_content, re.IGNORECASE):
-            return False
-    return True
-
-def compute_file_hash(file_path):
-    """Compute SHA256 hash of a file."""
-    sha256_hash = hashlib.sha256()
-    with open(file_path, "rb") as f:
-        for byte_block in iter(lambda: f.read(4096), b""):
-            sha256_hash.update(byte_block)
-    return sha256_hash.hexdigest()
-
-def main():
-    if len(sys.argv) < 3:
-        print("Usage: python patch.py <patch_file> <target_file>")
+def apply_patch_safely(patch_path, target_dir='.'):
+    try:
+        validate_patch_file(patch_path)
+        # Change to target directory for safety
+        original_cwd = os.getcwd()
+        os.chdir(target_dir)
+        # Apply patch with limited permissions
+        result = subprocess.run(['patch', '-p1'], input=open(patch_path, 'rb'), capture_output=True, text=True)
+        os.chdir(original_cwd)
+        if result.returncode != 0:
+            raise RuntimeError(f"Patch failed: {result.stderr}")
+        print("Patch applied successfully.")
+    except Exception as e:
+        print(f"Security or application error: {e}")
         sys.exit(1)
 
+if __name__ == "__main__":
+    if len(sys.argv) < 2:
+        print("Usage: python patch.py <patch_file> [target_dir]")
+        sys.exit(1)
     patch_file = sys.argv[1]
-    target_file = sys.argv[2]
-
-    # Security Check 1: Validate patch file existence and readability
-    if not os.path.exists(patch_file):
-        print(f"Error: Patch file '{patch_file}' not found.")
-        sys.exit(1)
-    if not os.access(patch_file, os.R_OK):
-        print(f"Error: Cannot read patch file '{patch_file}'.")
-        sys.exit(1)
-
-    # Security Check 2: Validate target file path safety
-    if not is_safe_path(os.path.basename(target_file)):
-        print(f"Error: Unsafe target path '{target_file}'.")
-        sys.exit(1)
-
-    # Security Check 3: Ensure target directory is writable
-    target_dir = os.path.dirname(target_file) or '.'
-    if not os.access(target_dir, os.W_OK):
-        print(f"Error: Cannot write to directory '{target_dir}'.")
-        sys.exit(1)
-
-    # Security Check 4: Validate patch content
-    with open(patch_file, 'r') as f:
-        patch_content = f.read()
-    if not validate_patch_content(patch_content):
-        print("Error: Patch contains potentially malicious content.")
-        sys.exit(1)
-
-    # Security Check 5: Backup original file if exists
-    if os.path.exists(target_file):
-        original_hash = compute_file_hash(target_file)
-        backup_file = target_file + ".backup"
-        os.rename(target_file, backup_file)
-        print(f"Backup created: {backup_file} (original hash: {original_hash})")
-
-    # Apply patch using subprocess with restricted environment
-    try:
-        # Create a temporary directory for safe patching
-        with tempfile.TemporaryDirectory() as temp_dir:
-            temp_target = os.path.join(temp_dir, os.path.basename(target_file))
-            # Copy patch to temp if needed, but apply directly
-            cmd = [
-                'patch',
-                '-p1',
-                '--directory=' + temp_dir,
-                '--input=' + patch_file,
-                '--output=' + temp_target
-            ]
-            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
-            print(f"Patch applied successfully in temp: {result.stdout}")
-
-            # Verify the patched file
-            new_hash = compute_file_hash(temp_target)
-            print(f"New file hash: {new_hash}")
-
-            # Move to target
-            os.rename(temp_target, target_file)
-            print(f"Patched file moved to: {target_file}")
-
-    except subprocess.CalledProcessError as e:
-        print(f"Error applying patch: {e.stderr}")
-        # Restore backup if exists
-        if os.path.exists(backup_file):
-            os.rename(backup_file, target_file)
-            print("Restored from backup.")
-        sys.exit(1)
-    except Exception as e:
-        print(f"Unexpected error: {e}")
-        if os.path.exists(backup_file):
-            os.rename(backup_file, target_file)
-            print("Restored from backup.")
-        sys.exit(1)
-
-    print("Patch application completed with security checks.")
-
-if __name__ == '__main__':
-    main()
+    target_dir = sys.argv[2] if len(sys.argv) > 2 else '.'
+    apply_patch_safely(patch_file, target_dir)
