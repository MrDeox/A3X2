--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -2,105 +2,119 @@
 import os
 import subprocess
 import re
-import tempfile
-import shutil
+from pathlib import Path
 
 class SecurePatchApplier:
     def __init__(self):
-        self.backup_dir = None
+        self.target_dir = '.'
+        self.strip_level = 0
+        self.dry_run = False
+        self.backup = True
 
-    def validate_path(self, path):
-        """Validate that the path is safe to use."""
-        if not path or '..' in path or path.startswith('/'):
-            raise ValueError("Unsafe path detected")
-        return os.path.abspath(path)
+    def parse_arguments(self, args):
+        # Simple argument parsing for demo
+        for arg in args:
+            if arg.startswith('--target='):
+                self.target_dir = arg.split('=', 1)[1]
+            elif arg.startswith('--strip='):
+                self.strip_level = int(arg.split('=', 1)[1])
+            elif arg == '--dry-run':
+                self.dry_run = True
+            elif arg == '--no-backup':
+                self.backup = False
+
+    def validate_target_dir(self, target_dir):
+        if not os.path.isdir(target_dir):
+            raise ValueError(f"Target directory '{target_dir}' does not exist.")
+        # Security check: avoid system directories
+        abs_path = os.path.abspath(target_dir)
+        forbidden = ['/etc', '/usr', '/var', '/boot', '/root']
+        if any(abs_path.startswith(f) for f in forbidden):
+            raise ValueError(f"Cannot patch in system directory: {abs_path}")
+        return abs_path
 
     def validate_diff_content(self, diff_content):
-        """Basic validation of diff content to prevent malicious patches."""
-        if not isinstance(diff_content, str):
-            raise ValueError("Diff must be a string")
-        # Check for potentially dangerous commands
-        dangerous_patterns = [r'rm\s+.*', r'del\s+.*', r'exec\s+']
-        for pattern in dangerous_patterns:
-            if re.search(pattern, diff_content, re.IGNORECASE):
-                raise ValueError("Potentially dangerous content in diff")
+        # Basic validation: check if it's a valid unified diff
+        if not re.search(r'^\+{3} ', diff_content, re.MULTILINE):
+            raise ValueError("Invalid diff format: missing +++ header")
+        if not re.search(r'^\-{3} ', diff_content, re.MULTILINE):
+            raise ValueError("Invalid diff format: missing --- header")
+        # Check for potentially dangerous commands (e.g., shell injection if any)
+        if re.search(r'[;&|`$]', diff_content):
+            raise ValueError("Diff contains potentially dangerous characters")
         return True
 
-    def create_backup(self, target_file):
-        """Create a backup of the target file before patching."""
-        if not os.path.exists(target_file):
-            raise FileNotFoundError(f"Target file {target_file} does not exist")
-        self.backup_dir = tempfile.mkdtemp()
-        backup_path = os.path.join(self.backup_dir, os.path.basename(target_file) + '.bak')
-        shutil.copy2(target_file, backup_path)
-        print(f"Backup created: {backup_path}")
+    def extract_target_files(self, diff_content):
+        # Extract potential target files from diff headers
+        targets = set()
+        for line in diff_content.splitlines():
+            if line.startswith('--- '):
+                path = line[4:].strip()
+                if path and not path.startswith('/dev/'):
+                    targets.add(path)
+        return list(targets)
 
-    def restore_backup(self):
-        """Restore from backup if needed."""
-        if self.backup_dir and os.path.exists(self.backup_dir):
-            # Logic to restore would go here
-            shutil.rmtree(self.backup_dir)
-            print("Backup restored and cleaned up.")
+    def check_file_permissions(self, target_files):
+        for file_path in target_files:
+            abs_path = os.path.join(self.target_dir, file_path.lstrip('/'))
+            if os.path.exists(abs_path):
+                if not os.access(abs_path, os.W_OK):
+                    raise PermissionError(f"No write permission for {abs_path}")
+            # Ensure not patching executables without confirmation (simplified)
+            if os.path.isfile(abs_path) and os.access(abs_path, os.X_OK):
+                print(f"Warning: {abs_path} is executable. Proceed with caution.")
 
-    def apply_patch(self, diff_content, target_file, strip=0):
-        """Apply patch with security checks."""
+    def apply_patch(self, diff_path=None, diff_content=None):
+        if diff_path:
+            with open(diff_path, 'r') as f:
+                diff_content = f.read()
+        elif not diff_content:
+            raise ValueError("Provide either diff_path or diff_content")
+
+        self.validate_diff_content(diff_content)
+        target_files = self.extract_target_files(diff_content)
+        self.check_file_permissions(target_files)
+        validated_dir = self.validate_target_dir(self.target_dir)
+
+        # Prepare patch command with safety options
+        cmd = ['patch', '-d', validated_dir, '-p' + str(self.strip_level)]
+        if self.dry_run:
+            cmd.append('--dry-run')
+        if self.backup:
+            cmd.append('-b')
+        cmd.extend(['--reject-file=-', '--forward', '--batch'])
+
+        # Security: Use stdin for diff to avoid file-based injection
         try:
-            target_file = self.validate_path(target_file)
-            self.validate_diff_content(diff_content)
-            self.create_backup(target_file)
+            if self.dry_run:
+                print("Dry run mode: Not applying patch.")
+                result = subprocess.run(cmd, input=diff_content.encode(), capture_output=True, text=True)
+            else:
+                with subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True) as proc:
+                    stdout, stderr = proc.communicate(input=diff_content)
+                result = subprocess.CompletedProcess(cmd, proc.returncode, stdout, stderr)
 
-            # Write diff to temp file
-            with tempfile.NamedTemporaryFile(mode='w', suffix='.patch', delete=False) as f:
-                f.write(diff_content)
-                patch_file = f.name
+            if result.returncode != 0:
+                raise RuntimeError(f"Patch failed: {result.stderr}")
+            print("Patch applied successfully.")
+            return True
+        except subprocess.SubprocessError as e:
+            raise RuntimeError(f"Error executing patch: {e}")
 
-            # Use patch command with safety options
-            cmd = [
-                'patch',
-                '-p', str(strip),
-                '--input=' + patch_file,
-                '--backup',  # Create backup
-                '--reject-file=-',  # Output rejects to stdout
-                target_file
-            ]
-
-            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
-            print("Patch applied successfully.")
-            print(result.stdout)
-            if result.stderr:
-                print("Warnings:", result.stderr)
-
-        except subprocess.CalledProcessError as e:
-            print(f"Patch failed: {e}")
-            print(e.stderr)
-            self.restore_backup()
-            raise
+    def run(self, args):
+        self.parse_arguments(args[1:] if args else [])
+        # For demo, assume diff from stdin or file
+        diff_input = sys.stdin.read().strip()
+        if not diff_input:
+            print("No diff provided. Usage: python patch.py [--target=DIR] [--strip=N] < diff.patch")
+            return 1
+        try:
+            self.apply_patch(diff_content=diff_input)
+            return 0
         except Exception as e:
-            print(f"Error: {e}")
-            self.restore_backup()
-            raise
-        finally:
-            if 'patch_file' in locals() and os.path.exists(patch_file):
-                os.unlink(patch_file)
-
-    def cleanup(self):
-        if self.backup_dir:
-            shutil.rmtree(self.backup_dir, ignore_errors=True)
+            print(f"Error: {e}", file=sys.stderr)
+            return 1
 
 if __name__ == '__main__':
-    if len(sys.argv) < 3:
-        print("Usage: python patch.py <diff_file> <target_file> [strip_level]")
-        sys.exit(1)
-
     applier = SecurePatchApplier()
-    try:
-        with open(sys.argv[1], 'r') as f:
-            diff_content = f.read()
-        target_file = sys.argv[2]
-        strip = int(sys.argv[3]) if len(sys.argv) > 3 else 0
-        applier.apply_patch(diff_content, target_file, strip)
-    except Exception as e:
-        print(f"Failed: {e}")
-        sys.exit(1)
-    finally:
-        applier.cleanup()+    sys.exit(applier.run(sys.argv))
