--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -3,83 +3,76 @@
 import os
 import subprocess
 import tempfile
-import difflib
 import hashlib
+import re
 
-# Security checks added: validate inputs, check file permissions, hash verification for patches
-
-def validate_patch(patch_content):
-    """Basic validation for patch content to prevent malicious patches."""
-    if not patch_content.strip():
-        raise ValueError("Empty patch provided.")
-    # Check for potentially dangerous commands (basic regex check)
-    dangerous_patterns = [r'rm\s+-rf', r'dd\s+if=/dev/zero', r'chmod\s+777']
+def validate_patch_file(patch_path):
+    if not os.path.exists(patch_path):
+        raise ValueError(f"Patch file {patch_path} does not exist.")
+    with open(patch_path, 'r') as f:
+        content = f.read()
+    # Basic check for malicious patterns, e.g., no exec or dangerous commands
+    dangerous_patterns = [r'\b(exec|eval|os\.system|subprocess\.call)\b', r'rm -rf', r'dd if=/dev/zero']
     for pattern in dangerous_patterns:
-        import re
-        if re.search(pattern, patch_content, re.IGNORECASE):
-            raise ValueError(f"Potentially dangerous content detected: {pattern}")
+        if re.search(pattern, content, re.IGNORECASE):
+            raise ValueError(f"Potential malicious content detected in patch: {pattern}")
     return True
 
-def compute_hash(content):
-    """Compute SHA256 hash for verification."""
-    return hashlib.sha256(content.encode()).hexdigest()
+def compute_patch_hash(patch_path):
+    hasher = hashlib.sha256()
+    with open(patch_path, 'rb') as f:
+        while chunk := f.read(4096):
+            hasher.update(chunk)
+    return hasher.hexdigest()
 
-def safe_apply_patch(target_file, patch_file):
-    """Apply patch with safety checks."""
-    if not os.path.exists(target_file):
-        raise FileNotFoundError(f"Target file {target_file} does not exist.")
+def safe_apply_patch(patch_path, target_dir, strip=0):
+    # Validate patch
+    validate_patch_file(patch_path)
+    patch_hash = compute_patch_hash(patch_path)
+    print(f"Patch validated. Hash: {patch_hash}")
     
-    # Check permissions: ensure we own the file or have write access
-    if not os.access(target_file, os.W_OK):
-        raise PermissionError(f"No write access to {target_file}")
+    # Use tempfile for safety
+    with tempfile.TemporaryDirectory() as temp_dir:
+        temp_patch = os.path.join(temp_dir, 'safe_patch')
+        with open(temp_patch, 'w') as f:
+            with open(patch_path, 'r') as orig:
+                f.write(orig.read())
+        
+        # Run patch command with restrictions
+        cmd = ['patch', '-d', target_dir, '-p', str(strip), '--dry-run', '-i', temp_patch]
+        try:
+            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
+            print("Dry run successful.")
+            # If dry run ok, apply for real
+            cmd[-1] = temp_patch  # Remove --dry-run
+            cmd.remove('--dry-run')
+            subprocess.run(cmd, check=True)
+            print("Patch applied safely.")
+        except subprocess.CalledProcessError as e:
+            print(f"Patch application failed: {e}")
+            raise
+
+def main():
+    if len(sys.argv) < 2:
+        print("Usage: python3 patch.py <patch_file> [target_dir] [strip_level]")
+        sys.exit(1)
     
-    with open(patch_file, 'r') as f:
-        patch_content = f.read()
+    patch_path = sys.argv[1]
+    target_dir = sys.argv[2] if len(sys.argv) > 2 else '.'
+    strip = int(sys.argv[3]) if len(sys.argv) > 3 else 0
     
-    validate_patch(patch_content)
-    
-    # Create backup
-    backup = target_file + '.bak'
-    if os.path.exists(backup):
-        os.remove(backup)
-    os.rename(target_file, backup)
+    if not os.path.isdir(target_dir):
+        print(f"Target directory {target_dir} does not exist.")
+        sys.exit(1)
     
     try:
-        # Use patch command with restrictions
-        cmd = ['patch', '-i', patch_file, target_file, '--backup', '--verbose']
-        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
-        if result.returncode != 0:
-            raise RuntimeError(f"Patch failed: {result.stderr}")
-        print(f"Patch applied successfully to {target_file}")
-    except subprocess.TimeoutExpired:
-        raise RuntimeError("Patch application timed out.")
+        safe_apply_patch(patch_path, target_dir, strip)
+    except ValueError as e:
+        print(f"Security check failed: {e}")
+        sys.exit(1)
     except Exception as e:
-        # Restore backup on failure
-        if os.path.exists(backup):
-            os.rename(backup, target_file)
-        raise e
+        print(f"Error applying patch: {e}")
+        sys.exit(1)
 
-if __name__ == "__main__":
-    if len(sys.argv) != 3:
-        print("Usage: python3 patch.py <target_file> <patch_file>")
-        sys.exit(1)
-    
-    target = sys.argv[1]
-    patch = sys.argv[2]
-    
-    # Validate paths: prevent absolute paths or parent directory traversal
-    if '..' in target or not os.path.abspath(target).startswith(os.getcwd()):
-        raise ValueError("Invalid target path.")
-    
-    if not os.path.isfile(patch):
-        raise FileNotFoundError(f"Patch file {patch} not found.")
-    
-    # Optional: verify patch hash if provided via env
-    expected_hash = os.environ.get('PATCH_HASH')
-    if expected_hash:
-        with open(patch, 'r') as f:
-            actual_hash = compute_hash(f.read())
-        if actual_hash != expected_hash:
-            raise ValueError("Patch hash mismatch.")
-    
-    safe_apply_patch(target, patch)
+if __name__ == '__main__':
+    main()