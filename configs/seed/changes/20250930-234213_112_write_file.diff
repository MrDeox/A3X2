--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -2,61 +2,95 @@
 import sys
 import os
 import subprocess
+import re
 
+def validate_patch_content(patch_content):
+    # Security check: Scan for potentially dangerous patterns in patch
+    dangerous_patterns = [
+        r'\s*rm\s',  # rm commands
+        r'\s*del\s',  # del commands
+        r'\s*format\s',  # format commands
+        r'\s*exec\s',  # exec
+        r'\s*system\s',  # system calls
+        r'\s*#include\s*<stdio.h>',  # C includes that might be malicious
+        r'\s*os.system\s',  # Python os.system
+    ]
+    for pattern in dangerous_patterns:
+        if re.search(pattern, patch_content, re.IGNORECASE):
+            return False, f"Dangerous pattern detected: {pattern}"
+    return True, "Safe"
 
-def apply_secure_patch(patch_file, target_dir):
-    # Security check: Verify patch file exists
+def apply_patch(patch_file, target_dir):
+    # Security check 1: Ensure patch_file exists and is readable
     if not os.path.exists(patch_file):
-        raise ValueError(f"Patch file '{patch_file}' does not exist.")
+        print(f"Error: Patch file '{patch_file}' not found.")
+        return 1
+    if not os.access(patch_file, os.R_OK):
+        print(f"Error: Cannot read patch file '{patch_file}'.")
+        return 1
 
-    # Security check: Verify patch file is readable
-    if not os.access(patch_file, os.R_OK):
-        raise ValueError(f"No read permission for patch file '{patch_file}'.")
+    # Security check 2: Read and validate patch content
+    try:
+        with open(patch_file, 'r') as f:
+            patch_content = f.read()
+        is_safe, message = validate_patch_content(patch_content)
+        if not is_safe:
+            print(f"Security violation: {message}")
+            return 1
+        print(f"Patch validation: {message}")
+    except Exception as e:
+        print(f"Error reading patch: {e}")
+        return 1
 
-    # Security check: Ensure patch file has safe extension
-    if not patch_file.endswith('.patch'):
-        raise ValueError("Patch file must have .patch extension for security.")
+    # Security check 3: Ensure target_dir is within current working directory to prevent path traversal
+    abs_target = os.path.abspath(target_dir)
+    abs_cwd = os.path.abspath(os.getcwd())
+    if not abs_target.startswith(abs_cwd):
+        print(f"Error: Target directory '{target_dir}' is outside the current working directory for security reasons.")
+        return 1
 
-    # Security check: Verify target directory exists and is writable
+    # Security check 4: Check if target_dir exists and is writable
     if not os.path.exists(target_dir):
-        raise ValueError(f"Target directory '{target_dir}' does not exist.")
+        print(f"Error: Target directory '{target_dir}' does not exist.")
+        return 1
+    if not os.access(target_dir, os.W_OK):
+        print(f"Error: Cannot write to target directory '{target_dir}'.")
+        return 1
 
-    if not os.access(target_dir, os.W_OK):
-        raise ValueError(f"No write permission for target directory '{target_dir}'.")
+    # Apply the patch using subprocess for controlled execution
+    try:
+        cmd = ['patch', '-p1', '--dry-run', '-d', target_dir, '<', patch_file]
+        # First, do a dry run to test
+        result_dry = subprocess.run(cmd, capture_output=True, text=True)
+        if result_dry.returncode != 0:
+            print("Dry run failed - patch would not apply cleanly.")
+            print(result_dry.stderr)
+            return 1
+        print("Dry run successful.")
 
-    # Security check: Limit patch to target directory only (no --forward or recursive risks)
-    try:
-        result = subprocess.run(
-            ['patch', '-p1', '-d', target_dir, '-i', patch_file, '--dry-run'],
-            capture_output=True,
-            text=True,
-            check=True
-        )
-        print("Dry run successful. Proceeding with patch application.")
-    except subprocess.CalledProcessError as e:
-        raise ValueError(f"Dry run failed: {e.stderr}")
+        # Now apply for real
+        cmd = ['patch', '-p1', '-d', target_dir, '<', patch_file]
+        result = subprocess.run(cmd, capture_output=True, text=True)
+        if result.returncode != 0:
+            print("Patch application failed.")
+            print(result.stderr)
+            return 1
+        print("Patch applied successfully.")
+        return 0
+    except Exception as e:
+        print(f"Error during patch application: {e}")
+        return 1
 
-    # Apply the patch
-    try:
-        subprocess.check_call(['patch', '-p1', '-d', target_dir, '-i', patch_file])
-        print(f"Patch applied successfully to '{target_dir}'.")
-    except subprocess.CalledProcessError as e:
-        raise RuntimeError(f"Patch application failed: {e}")
-
-
-def main():
+if __name__ == "__main__":
     if len(sys.argv) != 3:
         print("Usage: python patch.py <patch_file> <target_dir>")
+        print("Security features: Validates patch content, restricts target dir, dry-run test.")
         sys.exit(1)
 
     patch_file = sys.argv[1]
     target_dir = sys.argv[2]
 
-    try:
-        apply_secure_patch(patch_file, target_dir)
-    except (ValueError, RuntimeError) as e:
-        print(f"Error: {e}", file=sys.stderr)
-        sys.exit(1)
+    # Additional security: Log the action
+    print(f"Applying patch '{patch_file}' to '{target_dir}'...")
 
-if __name__ == '__main__':
-    main()+    sys.exit(apply_patch(patch_file, target_dir))
