--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -2,84 +2,92 @@
 import sys
 import os
 import subprocess
+import argparse
+import hashlib
+import tempfile
 
+# Security checks
+def validate_patch_file(patch_path):
+    if not os.path.exists(patch_path):
+        raise FileNotFoundError(f"Patch file not found: {patch_path}")
+    if not os.path.isfile(patch_path):
+        raise ValueError(f"{patch_path} is not a file")
+    # Check file size to prevent huge files
+    if os.path.getsize(patch_path) > 10 * 1024 * 1024:  # 10MB limit
+        raise ValueError("Patch file too large")
+    # Basic content validation: ensure it's text and looks like a diff
+    with open(patch_path, 'r', encoding='utf-8', errors='ignore') as f:
+        content = f.read(1024)  # Read first 1KB
+        if not any(line.startswith(('---', '+++', '@@', 'diff')) for line in content.splitlines()):
+            raise ValueError("Invalid patch format")
+    return True
 
-def validate_inputs(file_path, patch_path):
-    """Validações de segurança básicas para os inputs."""
-    # Verificar se os argumentos foram fornecidos
-    if not file_path or not patch_path:
-        raise ValueError("File path and patch path are required.")
+def compute_file_hash(file_path):
+    hasher = hashlib.sha256()
+    with open(file_path, 'rb') as f:
+        for chunk in iter(lambda: f.read(4096), b''):
+            hasher.update(chunk)
+    return hasher.hexdigest()
 
-    # Verificar existência dos arquivos
-    if not os.path.exists(file_path):
-        raise FileNotFoundError(f"Target file does not exist: {file_path}")
-    if not os.path.exists(patch_path):
-        raise FileNotFoundError(f"Patch file does not exist: {patch_path}")
-
-    # Verificar permissões no arquivo alvo (leitura e escrita)
-    if not os.access(file_path, os.R_OK | os.W_OK):
-        raise PermissionError(f"Insufficient permissions for {file_path}")
-
-    # Verificar se o patch não é muito grande (limite de segurança, ex: 1MB)
-    if os.path.getsize(patch_path) > 1024 * 1024:
-        raise ValueError("Patch file too large, potential security risk.")
-
-    # Evitar caminhos absolutos ou com '..' para prevenir directory traversal
-    if os.path.isabs(file_path) or '..' in os.path.normpath(file_path):
-        raise ValueError("Invalid target file path: potential traversal attempt.")
-    if os.path.isabs(patch_path) or '..' in os.path.normpath(patch_path):
-        raise ValueError("Invalid patch file path: potential traversal attempt.")
-
-    # Verificar se o patch contém comandos perigosos (básico: checar por ; ou |)
-    with open(patch_path, 'r') as f:
-        content = f.read()
-        if any(cmd in content for cmd in [';', '|', '&', '`']):
-            raise ValueError("Patch contains suspicious shell metacharacters.")
-
-
-def apply_patch_safely(file_path, patch_path):
-    """Aplica o patch de forma segura usando subprocess."""
-    try:
-        with open(patch_path, 'rb') as patch_file:
-            result = subprocess.run(
-                ['patch', '-p1', file_path],
-                input=patch_file.read(),
-                capture_output=True,
-                text=False,
-                check=True
-            )
-        return True
-    except subprocess.CalledProcessError as e:
-        print(f"Patch application failed: {e}")
-        print(f"Stdout: {e.stdout.decode() if e.stdout else ''}")
-        print(f"Stderr: {e.stderr.decode() if e.stderr else ''}")
-        return False
-    except Exception as e:
-        print(f"Unexpected error: {e}")
-        return False
-
+def backup_file(file_path):
+    backup_path = file_path + '.bak'
+    if os.path.exists(backup_path):
+        os.remove(backup_path)
+    os.rename(file_path, backup_path)
+    return backup_path
 
 def main():
-    if len(sys.argv) != 3:
-        print("Usage: python patch.py <target_file> <patch_file>")
+    parser = argparse.ArgumentParser(description='Apply patches with security checks')
+    parser.add_argument('patch_file', help='Path to the patch file')
+    parser.add_argument('target_file', nargs='?', default=None, help='Target file to patch (optional, inferred from patch)')
+    parser.add_argument('--dry-run', action='store_true', help='Dry run without applying')
+    parser.add_argument('--no-backup', action='store_true', help='Do not create backup')
+
+    args = parser.parse_args()
+
+    # Security: Validate inputs
+    if not args.patch_file:
+        raise ValueError("Patch file is required")
+    validate_patch_file(args.patch_file)
+
+    # Determine target file if not provided
+    if not args.target_file:
+        with open(args.patch_file, 'r') as f:
+            for line in f:
+                if line.startswith('--- '):
+                    args.target_file = line[4:].strip().lstrip('a/')
+                    break
+        if not args.target_file:
+            raise ValueError("Could not infer target file from patch")
+
+    # Security: Check permissions
+    if not os.access(args.target_file, os.W_OK):
+        raise PermissionError(f"No write permission for {args.target_file}")
+
+    # Compute hash before applying
+    original_hash = compute_file_hash(args.target_file)
+
+    if not args.no_backup:
+        backup_file(args.target_file)
+
+    # Apply patch
+    cmd = ['patch', '-p1', '--input=' + args.patch_file, args.target_file]
+    if args.dry_run:
+        cmd.append('--dry-run')
+
+    try:
+        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
+        print("Patch applied successfully.")
+        if not args.dry_run:
+            new_hash = compute_file_hash(args.target_file)
+            if original_hash == new_hash:
+                print("Warning: File unchanged after patch.")
+    except subprocess.CalledProcessError as e:
+        print(f"Patch failed: {e.stderr}")
+        if not args.no_backup and os.path.exists(args.target_file + '.bak'):
+            os.rename(args.target_file + '.bak', args.target_file)
+            print("Restored from backup.")
         sys.exit(1)
 
-    file_path = sys.argv[1]
-    patch_path = sys.argv[2]
-
-    try:
-        validate_inputs(file_path, patch_path)
-        print(f"Validating inputs... OK")
-        if apply_patch_safely(file_path, patch_path):
-            print("Patch applied successfully.")
-            sys.exit(0)
-        else:
-            print("Patch application failed.")
-            sys.exit(1)
-    except Exception as e:
-        print(f"Security check failed: {e}")
-        sys.exit(1)
-
-
-if __name__ == "__main__":
+if __name__ == '__main__':
     main()