--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,68 +1,91 @@
 import sys
 import os
 import subprocess
+import re
 import argparse
 
+class SecurePatchApplier:
+    def __init__(self):
+        self.target_file = None
+        self.patch_content = None
+        self.dry_run = False
 
-def sanitize_path(path, base_dir):
-    """Sanitiza o caminho para prevenir directory traversal."""
-    abs_path = os.path.abspath(os.path.expanduser(path))
-    base_abs = os.path.abspath(base_dir)
-    if not abs_path.startswith(base_abs):
-        raise ValueError(f"Caminho inválido: {path} fora do diretório base {base_dir}")
-    return abs_path
+    def validate_target_file(self, target):
+        if not os.path.exists(target):
+            raise ValueError(f"Target file '{target}' does not exist.")
+        if not os.access(target, os.R_OK | os.W_OK):
+            raise PermissionError(f"No read/write access to '{target}'.")
+        # Avoid patching system files or outside current dir
+        if target.startswith('/') or '..' in target:
+            raise SecurityError(f"Patching '{target}' is not allowed for security reasons.")
+        self.target_file = target
 
+    def validate_patch_content(self, patch_str):
+        if not patch_str.strip():
+            raise ValueError("Patch content is empty.")
+        # Basic diff validation: check for unified diff format
+        if not re.search(r'^---\s+\S+', patch_str, re.MULTILINE):
+            raise ValueError("Invalid patch format: not a unified diff.")
+        # Check for dangerous commands (e.g., rm, chmod)
+        dangerous_patterns = [r'\b(rm|chmod|chown|sudo)\b', r';\s*']
+        for pattern in dangerous_patterns:
+            if re.search(pattern, patch_str, re.IGNORECASE):
+                raise SecurityError("Patch contains potentially dangerous operations.")
+        self.patch_content = patch_str
 
-def validate_file(file_path, must_exist=True):
-    """Valida se o arquivo existe e tem permissões de leitura/escrita."""
-    if must_exist:
-        if not os.path.exists(file_path):
-            raise FileNotFoundError(f"Arquivo não encontrado: {file_path}")
-        if not os.access(file_path, os.R_OK):
-            raise PermissionError(f"Sem permissão de leitura: {file_path}")
-    dir_path = os.path.dirname(file_path)
-    if dir_path and not os.access(dir_path, os.W_OK):
-        raise PermissionError(f"Sem permissão de escrita no diretório: {dir_path}")
+    def apply(self, target, patch_str, dry_run=False):
+        try:
+            self.dry_run = dry_run
+            self.validate_target_file(target)
+            self.validate_patch_content(patch_str)
 
+            if self.dry_run:
+                print("Dry run: Patch would be applied to", self.target_file)
+                print("Patch content:", self.patch_content)
+                return True
 
-def apply_secure_patch(original_file, patch_file, base_dir='.'):
-    """Aplica o patch de forma segura."""
-    try:
-        # Sanitizar caminhos
-        orig_path = sanitize_path(original_file, base_dir)
-        patch_path = sanitize_path(patch_file, base_dir)
+            # Write patch to temp file securely
+            temp_patch = '/tmp/secure_patch_' + str(os.getpid()) + '.diff'
+            with open(temp_patch, 'w') as f:
+                f.write(self.patch_content)
+            os.chmod(temp_patch, 0o600)  # Secure permissions
 
-        # Validar arquivos
-        validate_file(orig_path, must_exist=True)
-        validate_file(patch_path, must_exist=True)
-        validate_file(orig_path, must_exist=False)  # Para escrita posterior
+            # Use patch command with safe options
+            cmd = ['patch', '-p1', '--input=' + temp_patch, self.target_file]
+            if self.dry_run:
+                cmd.append('--dry-run')
 
-        # Executar patch com subprocess seguro (sem shell)
-        cmd = ['patch', '-p1', '--input=' + patch_path, orig_path]
-        result = subprocess.run(cmd, check=True, capture_output=True, text=True)
+            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
+            if result.returncode == 0:
+                print("Patch applied successfully.")
+                return True
+            else:
+                print("Patch failed:", result.stderr)
+                return False
+        except subprocess.CalledProcessError as e:
+            print(f"Patch application failed: {e}")
+            return False
+        except (ValueError, PermissionError, SecurityError) as e:
+            print(f"Security validation failed: {e}")
+            return False
+        finally:
+            if 'temp_patch' in locals() and os.path.exists(temp_patch):
+                os.remove(temp_patch)
 
-        print("Patch aplicado com sucesso.")
-        if result.stdout:
-            print("Saída:", result.stdout)
-        if result.stderr:
-            print("Avisos:", result.stderr)
-
-    except subprocess.CalledProcessError as e:
-        print(f"Falha ao aplicar patch: {e}")
-        if e.stderr:
-            print("Erro:", e.stderr)
-        sys.exit(1)
-    except (ValueError, FileNotFoundError, PermissionError) as e:
-        print(f"Erro de validação: {e}")
-        sys.exit(1)
-
+    class SecurityError(Exception):
+        pass
 
 if __name__ == '__main__':
-    parser = argparse.ArgumentParser(description='Aplica patches de forma segura.')
-    parser.add_argument('original', help='Arquivo original')
-    parser.add_argument('patch', help='Arquivo de patch')
-    parser.add_argument('--base-dir', default='.', help='Diretório base para sanitização')
+    parser = argparse.ArgumentParser(description='Secure patch applicator')
+    parser.add_argument('target', help='Target file to patch')
+    parser.add_argument('patch_file', help='Patch file')
+    parser.add_argument('--dry-run', action='store_true', help='Dry run without applying')
 
     args = parser.parse_args()
 
-    apply_secure_patch(args.original, args.patch, args.base_dir)
+    applier = SecurePatchApplier()
+    with open(args.patch_file, 'r') as f:
+        patch_content = f.read()
+
+    success = applier.apply(args.target, patch_content, args.dry_run)
+    sys.exit(0 if success else 1)
