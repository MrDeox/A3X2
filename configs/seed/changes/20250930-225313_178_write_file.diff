--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,145 +1,73 @@
 import sys
 import os
 import subprocess
-import re
 import argparse
-from pathlib import Path
-
-class SecurePatchApplier:
-    def __init__(self, strip_level=0):
-        self.strip_level = strip_level
-        self.allowed_extensions = {'.py', '.txt', '.md', '.json', '.yaml', '.yml', '.xml', '.html', '.css', '.js'}
-        self.max_file_size = 10 * 1024 * 1024  # 10MB
-        self.max_patch_size = 1 * 1024 * 1024   # 1MB
-
-    def validate_patch_content(self, patch_content):
-        """Validate patch content for security."""
-        if len(patch_content) > self.max_patch_size:
-            raise ValueError("Patch too large.")
-        # Check for dangerous commands or patterns
-        dangerous_patterns = [
-            r'\b(rm|del|erase|format|mkfs|dd if=).*',
-            r'\b(chmod|chown|sudo).*',
-            r'\b(eval|exec|open\().*',
-            r'\b(import\s+(os|subprocess|sys).*',
-        ]
-        for pattern in dangerous_patterns:
-            if re.search(pattern, patch_content, re.IGNORECASE):
-                raise ValueError("Patch contains potentially dangerous content.")
-        return True
-
-    def validate_target_path(self, target_path):
-        """Ensure target path is safe."""
-        path_obj = Path(target_path)
-        if not path_obj.is_absolute():
-            path_obj = Path.cwd() / path_obj
-        # Prevent access to system directories
-        forbidden_dirs = ['/etc', '/bin', '/usr', '/var', '/root', '/sys', '/proc']
-        for forbidden in forbidden_dirs:
-            if str(path_obj).startswith(forbidden):
-                raise ValueError(f"Cannot patch files in {forbidden}.")
-        # Check file extension
-        if path_obj.suffix and path_obj.suffix not in self.allowed_extensions:
-            raise ValueError(f"Unsupported file extension: {path_obj.suffix}")
-        # Check file size
-        if path_obj.exists() and path_obj.stat().st_size > self.max_file_size:
-            raise ValueError("Target file too large.")
-        return str(path_obj)
-
-    def apply_patch(self, patch_file, target_dir=None, dry_run=False):
-        """Apply patch with security checks."""
-        if not os.path.exists(patch_file):
-            raise FileNotFoundError(f"Patch file not found: {patch_file}")
-
-        with open(patch_file, 'r') as f:
-            patch_content = f.read()
-        self.validate_patch_content(patch_content)
-
-        if target_dir:
-            target_dir = self.validate_target_path(target_dir)
-        else:
-            target_dir = os.getcwd()
-
-        # Use git apply if available for better safety, fallback to manual
-        try:
-            cmd = ['git', 'apply', '--check', patch_file]
-            if target_dir:
-                cmd += ['--directory', target_dir]
-            if dry_run:
-                cmd += ['--dry-run']
-            result = subprocess.run(cmd, capture_output=True, text=True, cwd=target_dir)
-            if result.returncode != 0:
-                raise ValueError(f"Patch validation failed: {result.stderr}")
-
-            if not dry_run:
-                cmd = ['git', 'apply', patch_file]
-                if target_dir:
-                    cmd += ['--directory', target_dir]
-                result = subprocess.run(cmd, capture_output=True, text=True, cwd=target_dir)
-                if result.returncode != 0:
-                    raise ValueError(f"Patch application failed: {result.stderr}")
-                print("Patch applied successfully using git.")
-        except FileNotFoundError:
-            # Fallback to manual patch application with safety
-            print("Git not available, using manual application.")
-            self._manual_apply(patch_content, target_dir, dry_run)
-
-    def _manual_apply(self, patch_content, target_dir, dry_run):
-        """Manual patch application (simplified for demo)."""
-        lines = patch_content.splitlines()
-        i = 0
-        while i < len(lines):
-            line = lines[i]
-            if line.startswith('--- '):
-                old_file = line[4:].strip()
-                if '/' in old_file:
-                    old_file = old_file.split('/')[-1]
-                i += 1
-                if i < len(lines) and lines[i].startswith('+++ '):
-                    new_file = lines[i][4:].strip()
-                    if '/' in new_file:
-                        new_file = new_file.split('/')[-1]
-                    target_path = os.path.join(target_dir, new_file)
-                    target_path = self.validate_target_path(target_path)
-                    if not dry_run:
-                        # Simplified: just log, in real impl parse hunks
-                        print(f"Would patch: {target_path}")
-                        # Actual parsing would go here with security checks per hunk
-                    else:
-                        print(f"Dry run: would patch {target_path}")
-                    i += 1
-            i += 1
-
-    def backup_target(self, target_path):
-        """Create backup before patching."""
-        if os.path.exists(target_path):
-            backup = target_path + '.bak'
-            if not os.path.exists(backup):
-                os.rename(target_path, backup)
-                print(f"Backup created: {backup}")
-            else:
-                print(f"Backup already exists: {backup}")
 
 
-def main():
-    parser = argparse.ArgumentParser(description='Secure patch applicator')
-    parser.add_argument('patch_file', help='Path to patch file')
-    parser.add_argument('-d', '--directory', help='Target directory')
-    parser.add_argument('-p', '--strip', type=int, default=0, help='Strip level')
-    parser.add_argument('--dry-run', action='store_true', help='Dry run')
-    parser.add_argument('--no-backup', action='store_true', help='Skip backup')
+def validate_path(path):
+    """Valida e sanitiza o caminho para prevenir directory traversal."""
+    if not path:
+        raise ValueError("Caminho não pode ser vazio.")
+    # Converte para caminho absoluto e resolve symlinks
+    abs_path = os.path.abspath(os.path.realpath(path))
+    # Verifica se está dentro do diretório atual ou especificado (aqui, assume cwd)
+    if not abs_path.startswith(os.getcwd()):
+        raise ValueError("Caminho fora do diretório permitido.")
+    return abs_path
 
-    args = parser.parse_args()
 
-    applier = SecurePatchApplier(strip_level=args.strip)
+def check_file_permissions(file_path, mode='r'):
+    """Verifica permissões do arquivo."""
+    if not os.path.exists(file_path):
+        raise FileNotFoundError(f"Arquivo não encontrado: {file_path}")
+    if mode == 'r' and not os.access(file_path, os.R_OK):
+        raise PermissionError(f"Sem permissão de leitura: {file_path}")
+    if mode == 'w' and not os.access(file_path, os.W_OK):
+        raise PermissionError(f"Sem permissão de escrita: {file_path}")
+    return True
 
+
+def apply_secure_patch(patch_file, target_dir, strip_level=1):
+    """Aplica o patch de forma segura usando subprocess sem shell."""
+    # Validações
+    patch_path = validate_path(patch_file)
+    target_path = validate_path(target_dir)
+    check_file_permissions(patch_path, 'r')
+    check_file_permissions(target_path, 'w')
+    
+    # Comando seguro: lista de argumentos, shell=False
+    cmd = [
+        'patch',
+        f'-p{strip_level}',
+        '-i', patch_path,
+        '--directory', target_path,
+        '--backup',  # Cria backup se possível
+        '--verbose'  # Para logging
+    ]
+    
     try:
-        if not args.no_backup and args.directory:
-            applier.backup_target(args.directory)
-        applier.apply_patch(args.patch_file, args.directory, args.dry_run)
-    except Exception as e:
-        print(f"Error: {e}", file=sys.stderr)
+        result = subprocess.run(cmd, check=True, capture_output=True, text=True)
+        print("Patch aplicado com sucesso.")
+        print(result.stdout)
+    except subprocess.CalledProcessError as e:
+        print(f"Erro ao aplicar patch: {e}")
+        print(e.stderr)
+        sys.exit(1)
+    except FileNotFoundError:
+        print("Comando 'patch' não encontrado. Instale o utilitário patch.")
         sys.exit(1)
 
-if __name__ == '__main__':
-    main()
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(description="Aplica patches de forma segura.")
+    parser.add_argument('patch_file', help="Arquivo de patch")
+    parser.add_argument('target_dir', help="Diretório alvo")
+    parser.add_argument('-p', '--strip', type=int, default=1, help="Nível de strip")
+    
+    args = parser.parse_args()
+    
+    try:
+        apply_secure_patch(args.patch_file, args.target_dir, args.strip)
+    except (ValueError, FileNotFoundError, PermissionError) as e:
+        print(f"Erro de validação: {e}")
+        sys.exit(1)
