--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,86 +1,84 @@
 import sys
 import os
 import subprocess
+import tempfile
 import shutil
+import re
 
-def apply_patch(patch_file, target_file):
-    # Security check: Ensure target file exists
-    if not os.path.exists(target_file):
-        print(f"Security check failed: Target file '{target_file}' does not exist.")
+# Security checks
+def validate_patch_content(patch_content):
+    # Basic validation: ensure it's a unified diff
+    if not re.search(r'^\+{3}', patch_content, re.MULTILINE):
+        return False, "Invalid patch format: missing +++ header"
+    if not re.search(r'^\-{3}', patch_content, re.MULTILINE):
+        return False, "Invalid patch format: missing --- header"
+    # Check for dangerous commands (e.g., rm, exec)
+    dangerous_patterns = [r'rm\s+.*', r'exec\s+.*', r'sudo\s+.*']
+    for pattern in dangerous_patterns:
+        if re.search(pattern, patch_content, re.IGNORECASE):
+            return False, f"Security violation: dangerous command '{pattern}' detected"
+    return True, "Patch validated"
+
+def confirm_apply(target_file):
+    print(f"Warning: About to apply patch to {target_file}. This may overwrite data.")
+    response = input("Do you want to proceed? (y/N): ").strip().lower()
+    return response == 'y'
+
+def safe_apply_patch(patch_file, target_dir='.'):
+    if not os.path.exists(patch_file):
+        print(f"Error: Patch file {patch_file} not found.")
         return False
     
-    # Security check: Ensure patch file exists and is readable
-    if not os.path.exists(patch_file):
-        print(f"Security check failed: Patch file '{patch_file}' does not exist.")
+    with open(patch_file, 'r') as f:
+        patch_content = f.read()
+    
+    is_valid, msg = validate_patch_content(patch_content)
+    if not is_valid:
+        print(f"Validation failed: {msg}")
         return False
     
-    # Create backup before applying
-    backup_file = target_file + '.backup'
-    try:
-        shutil.copy2(target_file, backup_file)
-        print(f"Backup created: {backup_file}")
-    except Exception as e:
-        print(f"Failed to create backup: {e}")
-        return False
+    # Find target files from patch
+    target_files = re.findall(r'^---\s+(a/)?(.*)', patch_content, re.MULTILINE)
+    for _, target in target_files:
+        target_path = os.path.join(target_dir, target.strip())
+        if not os.path.exists(os.path.dirname(target_path)):
+            print(f"Error: Directory for {target_path} does not exist.")
+            return False
+        if not confirm_apply(target_path):
+            print("Apply cancelled by user.")
+            return False
     
-    # Dry-run to test the patch without applying
-    try:
-        dry_run_result = subprocess.run(
-            ['patch', '--dry-run', '-p1', '-i', patch_file],
-            capture_output=True,
-            text=True,
-            check=False
-        )
-        if dry_run_result.returncode != 0:
-            print(f"Dry-run failed: {dry_run_result.stderr}")
-            # Restore backup (though not modified)
+    # Use temp dir for safety
+    with tempfile.TemporaryDirectory() as temp_dir:
+        temp_patch = os.path.join(temp_dir, 'patch')
+        shutil.copy(patch_file, temp_patch)
+        
+        cmd = ['patch', '-p1', '-d', target_dir, '--dry-run']
+        result = subprocess.run(cmd + [temp_patch], capture_output=True, text=True)
+        if result.returncode != 0:
+            print(f"Dry run failed: {result.stderr}")
             return False
-    except FileNotFoundError:
-        print("Error: 'patch' command not found. Ensure it's installed.")
-        return False
-    except Exception as e:
-        print(f"Unexpected error during dry-run: {e}")
-        return False
-    
-    # Apply the patch
-    try:
-        apply_result = subprocess.run(
-            ['patch', '-p1', '-i', patch_file],
-            capture_output=True,
-            text=True,
-            check=True
-        )
-        print("Patch applied successfully.")
-        # Optionally remove backup on success
-        # os.remove(backup_file)
-        return True
-    except subprocess.CalledProcessError as e:
-        print(f"Patch application failed: {e.stderr}")
-        # Restore from backup on failure
-        try:
-            os.replace(backup_file, target_file)
-            print(f"Restored from backup: {target_file}")
-        except Exception as restore_e:
-            print(f"Failed to restore backup: {restore_e}")
-        return False
-    except Exception as e:
-        print(f"Unexpected error during patch application: {e}")
-        # Attempt restore
-        try:
-            os.replace(backup_file, target_file)
-            print(f"Restored from backup: {target_file}")
-        except Exception as restore_e:
-            print(f"Failed to restore backup: {restore_e}")
-        return False
+        
+        print("Dry run successful. Applying patch...")
+        cmd = ['patch', '-p1', '-d', target_dir]
+        result = subprocess.run(cmd + [temp_patch], capture_output=True, text=True)
+        if result.returncode == 0:
+            print("Patch applied successfully.")
+            return True
+        else:
+            print(f"Apply failed: {result.stderr}")
+            return False
 
-if __name__ == "__main__":
-    if len(sys.argv) != 3:
-        print("Usage: python patch.py <patch_file> <target_file>")
-        print("Security note: This script includes checks for file existence, backups, and dry-runs.")
+if __name__ == '__main__':
+    if len(sys.argv) < 2:
+        print("Usage: python patch.py <patch_file> [target_dir]")
         sys.exit(1)
     
     patch_file = sys.argv[1]
-    target_file = sys.argv[2]
+    target_dir = sys.argv[2] if len(sys.argv) > 2 else '.'
     
-    success = apply_patch(patch_file, target_file)
-    sys.exit(0 if success else 1)
+    if not os.access(target_dir, os.W_OK):
+        print(f"Error: No write permission for {target_dir}")
+        sys.exit(1)
+    
+    safe_apply_patch(patch_file, target_dir)
