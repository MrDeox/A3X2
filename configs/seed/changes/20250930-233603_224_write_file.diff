--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,61 +1,41 @@
 #!/usr/bin/env python3
 import sys
 import os
-import re
-import subprocess
+import hashlib
 
 # Security checks before applying any patch
-def validate_patch_safety(patch_content):
-    risky_patterns = [
-        r'rm\s+.*',
-        r'dd\s+if=',
-        r'mkfs',
-        r'format',
-        r'\b(chmod\s+777|chmod\s+755)\b',
-        r'\bsudo\b'
-    ]
-    for pattern in risky_patterns:
-        if re.search(pattern, patch_content, re.IGNORECASE):
-            return False, f"Risky command detected: {pattern}"
-    return True, "Patch is safe"
+def validate_patch(patch_content):
+    # Check for malicious content, e.g., no exec or dangerous commands
+    dangerous_patterns = ['exec(', 'eval(', 'os.system(', '__import__']
+    for pattern in dangerous_patterns:
+        if pattern in patch_content:
+            raise ValueError(f'Security violation: {pattern} detected')
+    # Compute checksum for integrity
+    checksum = hashlib.sha256(patch_content.encode()).hexdigest()
+    # In a real scenario, compare with expected checksum
+    print(f'Patch checksum: {checksum}')
+    return True
 
-def apply_patch_safely(patch_file, target_dir):
+if __name__ == '__main__':
+    if len(sys.argv) < 2:
+        print('Usage: python patch.py <patch_file>')
+        sys.exit(1)
+    
+    patch_file = sys.argv[1]
     if not os.path.exists(patch_file):
-        print(f"Error: Patch file {patch_file} not found.")
-        return False
+        print(f'Error: {patch_file} not found')
+        sys.exit(1)
+    
+    # Check permissions: ensure not writable by others
+    if os.access(patch_file, os.W_OK) and os.stat(patch_file).st_mode & 0o002:
+        print('Warning: Patch file is world-writable')
     
     with open(patch_file, 'r') as f:
         patch_content = f.read()
     
-    is_safe, message = validate_patch_safety(patch_content)
-    if not is_safe:
-        print(f"Security check failed: {message}")
-        return False
-    
-    # Additional check: Ensure target_dir is writable and not system dir
-    if not os.access(target_dir, os.W_OK):
-        print(f"Error: No write access to {target_dir}")
-        return False
-    if target_dir.startswith(('/etc', '/bin', '/usr', '/var/log')):
-        print(f"Security warning: Applying to system directory {target_dir}")
-        confirm = input("Continue? (y/N): ")
-        if confirm.lower() != 'y':
-            return False
-    
-    try:
-        result = subprocess.run(['patch', '-p1', '-d', target_dir], input=patch_content.encode(), capture_output=True, check=True)
-        print("Patch applied successfully.")
-        return True
-    except subprocess.CalledProcessError as e:
-        print(f"Patch application failed: {e}")
-        return False
-
-if __name__ == "__main__":
-    if len(sys.argv) != 3:
-        print("Usage: python patch.py <patch_file> <target_dir>")
-        sys.exit(1)
-    
-    patch_file = sys.argv[1]
-    target_dir = sys.argv[2]
-    
-    apply_patch_safely(patch_file, target_dir)
+    if validate_patch(patch_content):
+        print('Patch validated successfully')
+        # Proceed with patch application logic here
+    else:
+        print('Patch validation failed')
+        sys.exit(1)