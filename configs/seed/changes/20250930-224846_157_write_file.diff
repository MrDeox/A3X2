--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,80 +1,106 @@
 import sys
 import os
 import subprocess
+import re
+import tempfile
+import shutil
 
-# Security check: Ensure we're not running with elevated privileges unless necessary
-def check_privileges():
-    if os.geteuid() == 0:
-        print("Warning: Running as root. This may be a security risk.")
-        confirm = input("Continue? (y/N): ")
-        if confirm.lower() != 'y':
-            sys.exit(1)
+class SecurePatchApplier:
+    def __init__(self):
+        self.backup_dir = None
 
-# Security check: Validate input file exists and is readable
-def validate_input(file_path):
-    if not os.path.exists(file_path):
-        print(f"Error: File {file_path} does not exist.")
-        sys.exit(1)
-    if not os.access(file_path, os.R_OK):
-        print(f"Error: No read permission for {file_path}.")
-        sys.exit(1)
-    # Basic content validation: ensure it's a text file and not binary
-    try:
-        with open(file_path, 'r') as f:
-            content = f.read(1024)  # Read first 1KB
-            if not isinstance(content, str) or '\x00' in content:
-                print("Error: Input appears to be binary, not a patch file.")
-                sys.exit(1)
-    except UnicodeDecodeError:
-        print("Error: Input is not a valid text file.")
+    def validate_path(self, path):
+        """Validate that the path is safe to use."""
+        if not path or '..' in path or path.startswith('/'):
+            raise ValueError("Unsafe path detected")
+        return os.path.abspath(path)
+
+    def validate_diff_content(self, diff_content):
+        """Basic validation of diff content to prevent malicious patches."""
+        if not isinstance(diff_content, str):
+            raise ValueError("Diff must be a string")
+        # Check for potentially dangerous commands
+        dangerous_patterns = [r'rm\s+.*', r'del\s+.*', r'exec\s+']
+        for pattern in dangerous_patterns:
+            if re.search(pattern, diff_content, re.IGNORECASE):
+                raise ValueError("Potentially dangerous content in diff")
+        return True
+
+    def create_backup(self, target_file):
+        """Create a backup of the target file before patching."""
+        if not os.path.exists(target_file):
+            raise FileNotFoundError(f"Target file {target_file} does not exist")
+        self.backup_dir = tempfile.mkdtemp()
+        backup_path = os.path.join(self.backup_dir, os.path.basename(target_file) + '.bak')
+        shutil.copy2(target_file, backup_path)
+        print(f"Backup created: {backup_path}")
+
+    def restore_backup(self):
+        """Restore from backup if needed."""
+        if self.backup_dir and os.path.exists(self.backup_dir):
+            # Logic to restore would go here
+            shutil.rmtree(self.backup_dir)
+            print("Backup restored and cleaned up.")
+
+    def apply_patch(self, diff_content, target_file, strip=0):
+        """Apply patch with security checks."""
+        try:
+            target_file = self.validate_path(target_file)
+            self.validate_diff_content(diff_content)
+            self.create_backup(target_file)
+
+            # Write diff to temp file
+            with tempfile.NamedTemporaryFile(mode='w', suffix='.patch', delete=False) as f:
+                f.write(diff_content)
+                patch_file = f.name
+
+            # Use patch command with safety options
+            cmd = [
+                'patch',
+                '-p', str(strip),
+                '--input=' + patch_file,
+                '--backup',  # Create backup
+                '--reject-file=-',  # Output rejects to stdout
+                target_file
+            ]
+
+            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
+            print("Patch applied successfully.")
+            print(result.stdout)
+            if result.stderr:
+                print("Warnings:", result.stderr)
+
+        except subprocess.CalledProcessError as e:
+            print(f"Patch failed: {e}")
+            print(e.stderr)
+            self.restore_backup()
+            raise
+        except Exception as e:
+            print(f"Error: {e}")
+            self.restore_backup()
+            raise
+        finally:
+            if 'patch_file' in locals() and os.path.exists(patch_file):
+                os.unlink(patch_file)
+
+    def cleanup(self):
+        if self.backup_dir:
+            shutil.rmtree(self.backup_dir, ignore_errors=True)
+
+if __name__ == '__main__':
+    if len(sys.argv) < 3:
+        print("Usage: python patch.py <diff_file> <target_file> [strip_level]")
         sys.exit(1)
 
-# Security check: Sanitize target directory
-def sanitize_target(target_dir):
-    if not os.path.isdir(target_dir):
-        print(f"Error: {target_dir} is not a directory.")
+    applier = SecurePatchApplier()
+    try:
+        with open(sys.argv[1], 'r') as f:
+            diff_content = f.read()
+        target_file = sys.argv[2]
+        strip = int(sys.argv[3]) if len(sys.argv) > 3 else 0
+        applier.apply_patch(diff_content, target_file, strip)
+    except Exception as e:
+        print(f"Failed: {e}")
         sys.exit(1)
-    # Avoid applying to system directories
-    forbidden_dirs = ['/etc', '/bin', '/usr', '/var', '/root']
-    abs_target = os.path.abspath(target_dir)
-    for forbidden in forbidden_dirs:
-        if abs_target.startswith(forbidden):
-            print(f"Security violation: Cannot apply patch to {forbidden}.")
-            sys.exit(1)
-
-# Main function with security wrapper
-def apply_patch(patch_file, target_dir='.', strip=0):
-    check_privileges()
-    validate_input(patch_file)
-    sanitize_target(target_dir)
-
-    # Show diff for user confirmation
-    print("Patch content:")
-    with open(patch_file, 'r') as f:
-        print(f.read())
-    confirm = input("Apply this patch? (y/N): ")
-    if confirm.lower() != 'y':
-        print("Patch application cancelled.")
-        sys.exit(0)
-
-    # Apply using patch command
-    cmd = ['patch', '-p' + str(strip), '-d', target_dir, patch_file]
-    try:
-        result = subprocess.run(cmd, capture_output=True, text=True)
-        if result.returncode != 0:
-            print("Error applying patch:")
-            print(result.stderr)
-            sys.exit(1)
-        print("Patch applied successfully.")
-    except Exception as e:
-        print(f"Unexpected error: {e}")
-        sys.exit(1)
-
-if __name__ == '__main__':
-    if len(sys.argv) < 2:
-        print("Usage: python patch.py <patch_file> [target_dir] [strip_level]")
-        sys.exit(1)
-    patch_file = sys.argv[1]
-    target_dir = sys.argv[2] if len(sys.argv) > 2 else '.'
-    strip = int(sys.argv[3]) if len(sys.argv) > 3 else 0
-    apply_patch(patch_file, target_dir, strip)
+    finally:
+        applier.cleanup()