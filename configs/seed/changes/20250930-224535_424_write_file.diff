--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -3,50 +3,60 @@
 import os
 import argparse
 
-# Security checks
+
 def validate_path(path):
+    """Validate that the path is safe and exists."""
     if not os.path.exists(path):
         raise ValueError(f"Path does not exist: {path}")
+    if not os.path.isfile(path):
+        raise ValueError(f"Path is not a file: {path}")
+    # Basic security: ensure it's not a symlink to sensitive areas (simplified)
     if os.path.islink(path):
-        raise ValueError(f"Symbolic links not allowed: {path}")
-    if not os.access(path, os.R_OK):
-        raise ValueError(f"No read permission: {path}")
+        raise ValueError(f"Path is a symlink, not allowed for security: {path}")
     return path
 
-def main():
-    parser = argparse.ArgumentParser(description='Secure patch applicator')
-    parser.add_argument('-p', '--strip', type=int, default=0, help='Strip directory levels')
-    parser.add_argument('patchfile', help='Patch file')
-    parser.add_argument('target', nargs='?', help='Target file/directory')
 
-    args = parser.parse_args()
+def validate_directory(dir_path):
+    """Validate target directory is safe."""
+    if not os.path.exists(dir_path):
+        os.makedirs(dir_path, exist_ok=True)
+    if not os.path.isdir(dir_path):
+        raise ValueError(f"Not a directory: {dir_path}")
+    # Security: ensure directory is within current working directory or specified safe root
+    abs_dir = os.path.abspath(dir_path)
+    abs_cwd = os.path.abspath(os.getcwd())
+    if not abs_dir.startswith(abs_cwd):
+        raise ValueError(f"Directory outside current working directory for security: {dir_path}")
+    return abs_dir
 
-    # Security: Validate inputs
-    try:
-        validate_path(args.patchfile)
-        if args.target:
-            validate_path(args.target)
-    except ValueError as e:
-        print(f"Security error: {e}", file=sys.stderr)
-        sys.exit(1)
 
-    # Build patch command with security
-    cmd = ['patch', '-p' + str(args.strip)]
-    if args.target:
-        cmd.extend(['-i', args.patchfile, args.target])
-    else:
-        cmd.extend(['-i', args.patchfile])
+def apply_patch(patch_file, target_dir=None, strip=1):
+    """Apply patch with security checks."""
+    patch_file = validate_path(patch_file)
+    if target_dir:
+        target_dir = validate_directory(target_dir)
+    
+    # Use subprocess with shell=False for security
+    cmd = ['patch', '-p', str(strip), '-i', patch_file]
+    if target_dir:
+        cmd.extend(['-d', target_dir])
+    
+    # Run with check=True to fail on error
+    result = subprocess.run(cmd, capture_output=True, text=True, check=True)
+    if result.returncode != 0:
+        raise RuntimeError(f"Patch failed: {result.stderr}")
+    print("Patch applied successfully.")
 
-    # Run with error checking
-    try:
-        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
-        print(result.stdout)
-    except subprocess.CalledProcessError as e:
-        print(f"Patch failed: {e.stderr}", file=sys.stderr)
-        sys.exit(1)
-    except FileNotFoundError:
-        print("patch command not found", file=sys.stderr)
-        sys.exit(1)
 
 if __name__ == '__main__':
-    main()+    parser = argparse.ArgumentParser(description='Secure patch applicator')
+    parser.add_argument('patch_file', help='Path to patch file')
+    parser.add_argument('-d', '--directory', help='Target directory')
+    parser.add_argument('-p', '--strip', type=int, default=1, help='Strip level')
+    
+    args = parser.parse_args()
+    try:
+        apply_patch(args.patch_file, args.directory, args.strip)
+    except Exception as e:
+        print(f"Error: {e}", file=sys.stderr)
+        sys.exit(1)
