--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -4,72 +4,103 @@
 import subprocess
 import tempfile
 import shutil
-import difflib
-
-# Security checks
-def validate_patch_safety(diff_content):
-    risky_patterns = [
-        r'rm\s+-rf',
-        r'dd\s+if=/dev/zero',
-        r'chmod\s+777',
-        r'exec\s+',
-        r'sudo\s+',
-    ]
-    for pattern in risky_patterns:
-        if re.search(pattern, diff_content, re.IGNORECASE):
-            return False, f"Risky command detected: {pattern}"
-    return True, "Safe"
-
+from pathlib import Path
 import re
 
-def apply_patch_safely(patch_file, target_dir):
-    if not os.path.exists(target_dir):
-        os.makedirs(target_dir)
-    if not os.path.isdir(target_dir):
-        return False, "Target is not a directory"
+# Security checks constants
+ALLOWED_EXTENSIONS = {'.py', '.txt', '.md'}
+MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB
+BLOCKED_PATHS = ['/etc/', '/var/log/', '/root/', '/proc/']
 
-    with open(patch_file, 'r') as f:
-        diff_content = f.read()
+class SecurePatcher:
+    def __init__(self):
+        self.temp_dir = None
 
-    is_safe, msg = validate_patch_safety(diff_content)
-    if not is_safe:
-        return False, msg
+    def validate_patch_content(self, patch_content):
+        """Validate patch content for security risks."""
+        # Check for potentially dangerous commands
+        dangerous_patterns = [
+            r'\s*(rm|del|format|mkfs|dd if=/dev/zero)',
+            r'\s*(chmod\s+777|chown\s+0:0)',
+            r'\s*(eval|exec|system\()',
+        ]
+        for pattern in dangerous_patterns:
+            if re.search(pattern, patch_content, re.IGNORECASE):
+                raise ValueError(f"Dangerous content detected: {pattern}")
+        # Check size
+        if len(patch_content) > MAX_FILE_SIZE:
+            raise ValueError("Patch too large")
+        return True
 
-    # Create a backup
-    backup_dir = target_dir + '.backup'
-    if os.path.exists(backup_dir):
-        shutil.rmtree(backup_dir)
-    shutil.copytree(target_dir, backup_dir)
+    def validate_target_path(self, target_path):
+        """Validate target file path."""
+        path = Path(target_path)
+        # Check extension
+        if path.suffix not in ALLOWED_EXTENSIONS:
+            raise ValueError(f"Unsupported file extension: {path.suffix}")
+        # Check for blocked paths
+        abs_path = path.resolve()
+        for blocked in BLOCKED_PATHS:
+            if str(abs_path).startswith(blocked):
+                raise ValueError(f"Blocked path: {abs_path}")
+        # Ensure it's writable
+        if not os.access(path.parent, os.W_OK):
+            raise ValueError(f"Cannot write to directory: {path.parent}")
+        return True
 
-    try:
-        result = subprocess.run(['patch', '-p1', '-d', target_dir], input=diff_content.encode(), capture_output=True)
-        if result.returncode == 0:
-            return True, "Patch applied successfully"
-        else:
-            # Revert backup
-            shutil.rmtree(target_dir)
-            shutil.copytree(backup_dir, target_dir)
-            return False, f"Patch failed: {result.stderr.decode()}"
-    except Exception as e:
-        # Revert
-        shutil.rmtree(target_dir)
-        shutil.copytree(backup_dir, target_dir)
-        return False, str(e)
+    def apply_patch(self, patch_file, target_file):
+        """Apply patch securely."""
+        try:
+            # Validate target
+            self.validate_target_path(target_file)
 
-if __name__ == "__main__":
-    if len(sys.argv) != 3:
-        print("Usage: python3 patch.py <patch_file> <target_dir>")
-        sys.exit(1)
+            # Read and validate patch
+            with open(patch_file, 'r') as f:
+                patch_content = f.read()
+            self.validate_patch_content(patch_content)
 
-    patch_file = sys.argv[1]
-    target_dir = os.path.abspath(sys.argv[2])
+            # Create backup
+            backup_file = target_file + '.backup'
+            shutil.copy2(target_file, backup_file)
 
-    # Additional security: ensure target_dir is under a safe root
-    safe_root = '/home/user/projects'  # Configure this
-    if not target_dir.startswith(safe_root):
-        print("Error: Target directory outside safe root")
-        sys.exit(1)
+            # Use patch command with restrictions
+            cmd = ['patch', '-p1', '--input=' + patch_file, target_file, '--backup', '--verbose']
+            # Run in a controlled environment
+            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
 
-    success, message = apply_patch_safely(patch_file, target_dir)
-    print(message)
-    sys.exit(0 if success else 1)
+            if result.returncode != 0:
+                # Restore backup on failure
+                shutil.copy2(backup_file, target_file)
+                raise RuntimeError(f"Patch failed: {result.stderr}")
+
+            # Clean up backup if successful
+            os.unlink(backup_file)
+            print("Patch applied successfully.")
+
+        except Exception as e:
+            print(f"Security error or failure: {e}")
+            if self.temp_dir:
+                shutil.rmtree(self.temp_dir, ignore_errors=True)
+            sys.exit(1)
+
+    def run(self):
+        if len(sys.argv) != 3:
+            print("Usage: python3 patch.py <patch_file> <target_file>")
+            sys.exit(1)
+
+        patch_file = sys.argv[1]
+        target_file = sys.argv[2]
+
+        if not os.path.exists(patch_file):
+            print("Patch file not found.")
+            sys.exit(1)
+
+        if not os.path.exists(target_file):
+            print("Target file not found.")
+            sys.exit(1)
+
+        self.apply_patch(patch_file, target_file)
+
+if __name__ == '__main__':
+    patcher = SecurePatcher()
+    patcher.run()