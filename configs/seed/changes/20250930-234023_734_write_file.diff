--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -2,124 +2,68 @@
 import sys
 import os
 import subprocess
-import re
+import tempfile
+import shutil
 
 
-def check_security(diff_content):
-    # Verificações de segurança básicas para padrões perigosos no diff
-    dangerous_patterns = [
-        r'os\.system\(',  # Execução de comandos do sistema
-        r'exec\(',        # Execução arbitrária de código
-        r'eval\(',        # Avaliação de expressões perigosas
-        r'rm\s+-rf',      # Comandos de remoção forçada
-        r'del\s+/f\s+/s\s+/q',  # Comandos de deleção no Windows
-        r'shutdown',       # Comandos de desligamento
-        r'\b(base64\.)?decode\(',  # Decodificação potencialmente maliciosa
-        r'\bimport\s+subprocess',   # Import suspeito em diffs de código
-        r'\bopen\s*\(',  # Abertura de arquivos sem verificação (potencial overwrite)
-    ]
-    for pattern in dangerous_patterns:
-        if re.search(pattern, diff_content, re.IGNORECASE | re.MULTILINE):
-            return False, f'Padrão perigoso detectado: {pattern}'
-    # Verificar se o diff afeta arquivos sensíveis (ex: /etc/passwd, mas adaptado para contexto)
-    sensitive_files = [r'/etc/passwd', r'/etc/shadow', r'\.ssh/']
-    for sens in sensitive_files:
-        if re.search(sens, diff_content, re.IGNORECASE):
-            return False, f'Tentativa de modificar arquivo sensível: {sens}'
-    # Verificar tamanho excessivo (potencial para payloads grandes)
-    if len(diff_content) > 10000:
-        return False, 'Diff muito grande, risco de payload malicioso'
-    return True, 'Diff seguro'
+def validate_patch(patch_content):
+    """Valida o conteúdo do patch para riscos de segurança."""
+    risks = []
+    if 'rm -rf' in patch_content or 'del /f /q' in patch_content:
+        risks.append('Potencial comando destrutivo detectado')
+    if len(patch_content) > 10000:
+        risks.append('Patch muito grande, risco de overflow')
+    return risks
 
 
-def analyze_risk_level(diff_content):
-    # Análise de risco mais avançada: pontuar riscos
-    risks = 0
-    medium_patterns = [r'\bprint\(', r'\binput\(']  # Exemplos de padrões de médio risco
-    for pattern in medium_patterns:
-        if re.search(pattern, diff_content, re.IGNORECASE):
-            risks += 1
-    if risks > 2:
-        return 'high'
-    elif risks > 0:
-        return 'medium'
-    return 'low'
+def apply_secure_patch(patch_file, target_dir):
+    """Aplica o patch de forma segura."""
+    if not os.path.exists(target_dir):
+        print(f"Diretório alvo não existe: {target_dir}")
+        return False
+
+    with open(patch_file, 'r') as f:
+        patch_content = f.read()
+
+    risks = validate_patch(patch_content)
+    if risks:
+        print(f"Riscos detectados: {risks}")
+        return False
+
+    # Cria backup
+    backup_dir = target_dir + '.backup'
+    if os.path.exists(backup_dir):
+        shutil.rmtree(backup_dir)
+    shutil.copytree(target_dir, backup_dir)
+
+    try:
+        result = subprocess.run(['patch', '-p1', '-d', target_dir], input=patch_content, text=True, capture_output=True)
+        if result.returncode != 0:
+            print(f"Falha ao aplicar patch: {result.stderr.decode()}")
+            # Restaura backup
+            shutil.rmtree(target_dir)
+            shutil.copytree(backup_dir, target_dir)
+            return False
+        print("Patch aplicado com sucesso.")
+        return True
+    except Exception as e:
+        print(f"Erro: {e}")
+        # Restaura backup
+        shutil.rmtree(target_dir)
+        shutil.copytree(backup_dir, target_dir)
+        return False
 
 
 if __name__ == '__main__':
-    if len(sys.argv) < 2:
-        print('Uso: python3 patch.py <arquivo_patch> [diretorio_alvo]')
-        print('Exemplo: python3 patch.py meu_patch.diff .')
+    if len(sys.argv) != 3:
+        print("Uso: python3 patch.py <patch_file> <target_dir>")
         sys.exit(1)
 
     patch_file = sys.argv[1]
-    target_dir = sys.argv[2] if len(sys.argv) > 2 else os.getcwd()
+    target_dir = sys.argv[2]
 
-    # Verificar se o arquivo patch existe
-    if not os.path.exists(patch_file):
-        print(f'Erro: Arquivo patch não encontrado: {patch_file}')
+    if not os.path.isfile(patch_file):
+        print(f"Arquivo de patch não encontrado: {patch_file}")
         sys.exit(1)
 
-    # Verificar permissões: não executar como root a menos que necessário
-    if os.geteuid() == 0:
-        print('Aviso: Executando como root. Considere usar um usuário não privilegiado.')
-        confirm = input('Continuar? (s/N): ')
-        if confirm.lower() != 's':
-            sys.exit(1)
-
-    # Ler o conteúdo do patch
-    try:
-        with open(patch_file, 'r') as f:
-            diff_content = f.read()
-    except Exception as e:
-        print(f'Erro ao ler patch: {e}')
-        sys.exit(1)
-
-    # Aplicar verificações de segurança
-    is_safe, msg = check_security(diff_content)
-    risk_level = analyze_risk_level(diff_content)
-
-    print(f'Nível de risco detectado: {risk_level}')
-    print(f'Mensagem de segurança: {msg}')
-
-    if not is_safe or risk_level == 'high':
-        print('Patch rejeitado devido a riscos de segurança altos.')
-        sys.exit(1)
-
-    if risk_level == 'medium':
-        confirm = input('Riscos médios detectados. Aplicar mesmo assim? (s/N): ')
-        if confirm.lower() != 's':
-            print('Aplicação cancelada pelo usuário.')
-            sys.exit(1)
-
-    # Aplicar o patch usando subprocess com captura de output
-    try:
-        cmd = ['patch', '-p1', '--dry-run', '-d', target_dir]  # Primeiro dry-run para teste
-        with open(patch_file, 'r') as f:
-            result = subprocess.run(cmd, stdin=subprocess.PIPE, input=f.read().encode(),
-                                    capture_output=True, text=True, cwd=target_dir)
-        if result.returncode != 0:
-            print('Falha no dry-run. Verifique o patch.')
-            print(result.stderr)
-            sys.exit(1)
-        print('Dry-run bem-sucedido. Aplicando patch...')
-
-        cmd = ['patch', '-p1', '-d', target_dir]  # Aplicação real
-        with open(patch_file, 'r') as f:
-            result = subprocess.run(cmd, stdin=subprocess.PIPE, input=f.read().encode(),
-                                    capture_output=True, text=True, cwd=target_dir)
-        if result.returncode == 0:
-            print('Patch aplicado com sucesso!')
-        else:
-            print('Falha ao aplicar patch:')
-            print(result.stderr)
-            sys.exit(1)
-    except FileNotFoundError:
-        print('Erro: Comando "patch" não encontrado. Instale o utilitário patch.')
-        sys.exit(1)
-    except subprocess.SubprocessError as e:
-        print(f'Erro no subprocess: {e}')
-        sys.exit(1)
-    except Exception as e:
-        print(f'Erro inesperado: {e}')
-        sys.exit(1)
+    apply_secure_patch(patch_file, target_dir)
