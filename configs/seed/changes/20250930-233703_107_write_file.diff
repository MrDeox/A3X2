--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -3,76 +3,95 @@
 import os
 import subprocess
 import tempfile
-import hashlib
-import re
+import shutil
 
-def validate_patch_file(patch_path):
-    if not os.path.exists(patch_path):
-        raise ValueError(f"Patch file {patch_path} does not exist.")
-    with open(patch_path, 'r') as f:
-        content = f.read()
-    # Basic check for malicious patterns, e.g., no exec or dangerous commands
-    dangerous_patterns = [r'\b(exec|eval|os\.system|subprocess\.call)\b', r'rm -rf', r'dd if=/dev/zero']
-    for pattern in dangerous_patterns:
-        if re.search(pattern, content, re.IGNORECASE):
-            raise ValueError(f"Potential malicious content detected in patch: {pattern}")
+
+def validate_path(path):
+    """Valida se o caminho é seguro (não absoluto para dirs sensíveis)."""
+    if not path or '..' in path or path.startswith('/'):
+        return False
     return True
 
-def compute_patch_hash(patch_path):
-    hasher = hashlib.sha256()
-    with open(patch_path, 'rb') as f:
-        while chunk := f.read(4096):
-            hasher.update(chunk)
-    return hasher.hexdigest()
 
-def safe_apply_patch(patch_path, target_dir, strip=0):
-    # Validate patch
-    validate_patch_file(patch_path)
-    patch_hash = compute_patch_hash(patch_path)
-    print(f"Patch validated. Hash: {patch_hash}")
-    
-    # Use tempfile for safety
-    with tempfile.TemporaryDirectory() as temp_dir:
-        temp_patch = os.path.join(temp_dir, 'safe_patch')
-        with open(temp_patch, 'w') as f:
-            with open(patch_path, 'r') as orig:
-                f.write(orig.read())
-        
-        # Run patch command with restrictions
-        cmd = ['patch', '-d', target_dir, '-p', str(strip), '--dry-run', '-i', temp_patch]
-        try:
-            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
-            print("Dry run successful.")
-            # If dry run ok, apply for real
-            cmd[-1] = temp_patch  # Remove --dry-run
-            cmd.remove('--dry-run')
-            subprocess.run(cmd, check=True)
-            print("Patch applied safely.")
-        except subprocess.CalledProcessError as e:
-            print(f"Patch application failed: {e}")
-            raise
+def safe_patch_apply(patch_diff, target_file):
+    """Aplica patch com verificações de segurança."""
+    # Verificação 1: Validar target_file
+    if not validate_path(target_file):
+        print("Erro: Caminho alvo inválido ou inseguro.")
+        return False
+    if not os.path.exists(target_file):
+        print(f"Erro: Arquivo {target_file} não existe.")
+        return False
+    if not os.access(target_file, os.R_OK | os.W_OK):
+        print(f"Erro: Sem permissões de leitura/escrita em {target_file}.")
+        return False
 
-def main():
-    if len(sys.argv) < 2:
-        print("Usage: python3 patch.py <patch_file> [target_dir] [strip_level]")
-        sys.exit(1)
-    
-    patch_path = sys.argv[1]
-    target_dir = sys.argv[2] if len(sys.argv) > 2 else '.'
-    strip = int(sys.argv[3]) if len(sys.argv) > 3 else 0
-    
-    if not os.path.isdir(target_dir):
-        print(f"Target directory {target_dir} does not exist.")
-        sys.exit(1)
-    
+    # Verificação 2: Validar conteúdo do patch (básico: não contém comandos perigosos)
+    dangerous_keywords = ['rm ', 'del ', 'exec(', 'eval(']
+    if any(keyword in patch_diff for keyword in dangerous_keywords):
+        print("Erro: Patch contém elementos potencialmente perigosos.")
+        return False
+
+    # Verificação 3: Usar temp file para teste
     try:
-        safe_apply_patch(patch_path, target_dir, strip)
-    except ValueError as e:
-        print(f"Security check failed: {e}")
-        sys.exit(1)
+        with tempfile.NamedTemporaryFile(mode='w', suffix='.tmp', delete=False) as tmp:
+            tmp.write(open(target_file).read())
+            tmp_path = tmp.name
+
+        # Aplicar patch no temp
+        result = subprocess.run(
+            ['patch', '--dry-run', '-i', '-'],
+            input=patch_diff,
+            text=True,
+            capture_output=True,
+            cwd=os.path.dirname(tmp_path) or '.'
+        )
+        if result.returncode != 0:
+            print("Erro: Patch seco falhou - possivelmente inválido.")
+            os.unlink(tmp_path)
+            return False
+
+        # Aplicar de verdade se seco OK
+        result = subprocess.run(
+            ['patch', '-i', '-'],
+            input=patch_diff,
+            text=True,
+            capture_output=True,
+            cwd=os.path.dirname(target_file) or '.'
+        )
+        if result.returncode == 0:
+            print("Patch aplicado com sucesso.")
+            os.unlink(tmp_path)
+            return True
+        else:
+            print(f"Falha ao aplicar patch: {result.stderr.decode()}")
+            # Reverta se possível, mas por simplicidade, avise
+            os.unlink(tmp_path)
+            return False
     except Exception as e:
-        print(f"Error applying patch: {e}")
+        print(f"Erro durante aplicação: {e}")
+        if 'tmp_path' in locals():
+            os.unlink(tmp_path)
+        return False
+
+
+if __name__ == "__main__":
+    if len(sys.argv) != 3:
+        print("Uso: ./patch.py <arquivo_patch> <arquivo_alvo>")
         sys.exit(1)
 
-if __name__ == '__main__':
-    main()+    patch_file = sys.argv[1]
+    target_file = sys.argv[2]
+
+    # Verificação de input
+    if not os.path.isfile(patch_file):
+        print(f"Erro: Patch file {patch_file} não encontrado.")
+        sys.exit(1)
+
+    try:
+        with open(patch_file, 'r') as f:
+            patch_diff = f.read()
+        safe_patch_apply(patch_diff, target_file)
+    except IOError as e:
+        print(f"Erro ao ler patch: {e}")
+        sys.exit(1)
