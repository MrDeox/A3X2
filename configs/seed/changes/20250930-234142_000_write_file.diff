--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -2,134 +2,61 @@
 import sys
 import os
 import subprocess
-import tempfile
-import hashlib
-
-
-def validate_patch(patch_content):
-    # Simple validation: check if it's a valid diff format
-    lines = patch_content.splitlines()
-    if not any(line.startswith('diff ') or line.startswith('--- ') for line in lines[:5]):
-        return False, "Invalid patch format"
-    # Check for potentially dangerous content (basic check for shell commands or exec)
-    dangerous_keywords = ['exec(', 'eval(', 'os.system', 'subprocess.call', '; rm']
-    if any(keyword in patch_content for keyword in dangerous_keywords):
-        return False, "Potentially dangerous content detected"
-    return True, "Valid"
-
-
-def check_target_safety(target_dir):
-    # Ensure target is not a system directory or absolute root
-    abs_path = os.path.abspath(target_dir)
-    dangerous_paths = ['/', '/etc', '/bin', '/usr', '/var', '/root']
-    if any(abs_path.startswith(dangerous) for dangerous in dangerous_paths):
-        return False, "Target directory is sensitive"
-    # Check for path traversal
-    if '..' in target_dir.split('/'):
-        return False, "Path traversal attempt detected"
-    return True, "Safe"
 
 
 def apply_secure_patch(patch_file, target_dir):
+    # Security check: Verify patch file exists
     if not os.path.exists(patch_file):
-        print("Error: Patch file not found")
-        return 1
+        raise ValueError(f"Patch file '{patch_file}' does not exist.")
 
-    with open(patch_file, 'r') as f:
-        patch_content = f.read()
+    # Security check: Verify patch file is readable
+    if not os.access(patch_file, os.R_OK):
+        raise ValueError(f"No read permission for patch file '{patch_file}'.")
 
-    is_valid, msg = validate_patch(patch_content)
-    if not is_valid:
-        print(f"Validation failed: {msg}")
-        return 1
+    # Security check: Ensure patch file has safe extension
+    if not patch_file.endswith('.patch'):
+        raise ValueError("Patch file must have .patch extension for security.")
 
-    safety_ok, safety_msg = check_target_safety(target_dir)
-    if not safety_ok:
-        print(f"Safety check failed: {safety_msg}")
-        return 1
+    # Security check: Verify target directory exists and is writable
+    if not os.path.exists(target_dir):
+        raise ValueError(f"Target directory '{target_dir}' does not exist.")
 
-    # Compute patch integrity hash
-    patch_hash = hashlib.sha256(patch_content.encode()).hexdigest()
-    print(f"Patch validated. Hash: {patch_hash[:16]}...")
+    if not os.access(target_dir, os.W_OK):
+        raise ValueError(f"No write permission for target directory '{target_dir}'.")
 
-    # Create backup of target dir if exists
-    backup_dir = target_dir + '.backup'
-    if os.path.exists(target_dir):
-        try:
-            import shutil
-            shutil.copytree(target_dir, backup_dir)
-            print(f"Backup created: {backup_dir}")
-        except Exception as e:
-            print(f"Backup failed: {e}")
-            return 1
-
-    # Dry run first
-    cmd = ['patch', '-p1', '-d', target_dir, '--dry-run', '--verbose']
+    # Security check: Limit patch to target directory only (no --forward or recursive risks)
     try:
-        result = subprocess.run(cmd, input=patch_content.encode(), capture_output=True, text=True, timeout=30)
-        if result.returncode != 0:
-            print("Dry run failed:")
-            print(result.stderr)
-            return 1
-        print("Dry run successful.")
-
-        # Check for sensitive file modifications in dry run output
-        output = result.stdout + result.stderr
-        sensitive_files = ['/etc/', '/bin/', '.ssh/', 'passwd']
-        if any(sensitive in output for sensitive in sensitive_files):
-            print("Patch attempts to modify sensitive files. Aborted.")
-            return 1
-    except subprocess.TimeoutExpired:
-        print("Patch application timed out")
-        return 1
-    except Exception as e:
-        print(f"Error in dry run: {e}")
-        return 1
+        result = subprocess.run(
+            ['patch', '-p1', '-d', target_dir, '-i', patch_file, '--dry-run'],
+            capture_output=True,
+            text=True,
+            check=True
+        )
+        print("Dry run successful. Proceeding with patch application.")
+    except subprocess.CalledProcessError as e:
+        raise ValueError(f"Dry run failed: {e.stderr}")
 
     # Apply the patch
-    cmd = ['patch', '-p1', '-d', target_dir, '--verbose']
     try:
-        result = subprocess.run(cmd, input=patch_content.encode(), capture_output=True, text=True, timeout=60)
-        if result.returncode == 0:
-            print("Patch applied successfully.")
-            return 0
-        else:
-            print("Patch application failed:")
-            print(result.stderr)
-            # Restore backup on failure
-            if os.path.exists(backup_dir):
-                shutil.rmtree(target_dir)
-                shutil.move(backup_dir, target_dir)
-                print("Restored from backup.")
-            return 1
-    except subprocess.TimeoutExpired:
-        print("Patch application timed out")
-        # Restore backup
-        if os.path.exists(backup_dir):
-            shutil.rmtree(target_dir)
-            shutil.move(backup_dir, target_dir)
-        return 1
-    except Exception as e:
-        print(f"Error applying patch: {e}")
-        # Restore backup
-        if os.path.exists(backup_dir):
-            shutil.rmtree(target_dir)
-            shutil.move(backup_dir, target_dir)
-        return 1
+        subprocess.check_call(['patch', '-p1', '-d', target_dir, '-i', patch_file])
+        print(f"Patch applied successfully to '{target_dir}'.")
+    except subprocess.CalledProcessError as e:
+        raise RuntimeError(f"Patch application failed: {e}")
 
 
-if __name__ == "__main__":
+def main():
     if len(sys.argv) != 3:
         print("Usage: python patch.py <patch_file> <target_dir>")
-        print("Security features: Validates patch, checks target safety, dry-run, backup, and timeout.")
         sys.exit(1)
 
     patch_file = sys.argv[1]
     target_dir = sys.argv[2]
 
-    # Additional arg validation
-    if not os.path.isfile(patch_file):
-        print("Error: Invalid patch file")
+    try:
+        apply_secure_patch(patch_file, target_dir)
+    except (ValueError, RuntimeError) as e:
+        print(f"Error: {e}", file=sys.stderr)
         sys.exit(1)
 
-    sys.exit(apply_secure_patch(patch_file, target_dir))
+if __name__ == '__main__':
+    main()