--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,47 +1,65 @@
 import sys
 import os
 import subprocess
-import argparse
 
-# Security checks
-def validate_patch_file(patch_path):
-    if not os.path.exists(patch_path):
-        raise ValueError(f'Patch file {patch_path} does not exist')
-    if not os.path.isfile(patch_path):
-        raise ValueError(f'{patch_path} is not a file')
-    # Check file size to prevent huge files
-    if os.path.getsize(patch_path) > 10 * 1024 * 1024:  # 10MB limit
-        raise ValueError('Patch file too large')
-    return True
 
-def safe_apply_patch(patch_path, target_dir='.'):
-    if not os.path.isdir(target_dir):
-        raise ValueError(f'Target directory {target_dir} does not exist')
-    # Use git apply with safety options
-    cmd = ['git', 'apply', '--check', patch_path]
+def apply_patch(patch_content, target_file):
+    # Security check: Ensure target file exists and is writable
+    if not os.path.exists(target_file):
+        print(f"Error: Target file {target_file} does not exist.")
+        return False
+    if not os.access(target_file, os.W_OK):
+        print(f"Error: No write permission for {target_file}.")
+        return False
+
+    # Security check: Limit patch size to prevent large malicious inputs
+    if len(patch_content) > 10000:
+        print("Error: Patch too large, potential security risk.")
+        return False
+
+    # Write patch to temporary file
+    with open('temp.patch', 'w') as f:
+        f.write(patch_content)
+
     try:
-        subprocess.run(cmd, cwd=target_dir, check=True, capture_output=True)
-    except subprocess.CalledProcessError as e:
-        raise RuntimeError(f'Patch check failed: {e.stderr.decode()}')
-    
-    # Apply if check passes
-    cmd = ['git', 'apply', patch_path]
-    result = subprocess.run(cmd, cwd=target_dir, check=True, capture_output=True)
-    return result.stdout.decode()
+        # Dry run first for safety
+        result = subprocess.run(['patch', '--dry-run', '-p1', '-i', 'temp.patch', '--forward'], 
+                                capture_output=True, text=True, cwd=os.path.dirname(target_file))
+        if result.returncode != 0:
+            print("Dry run failed: Patch would not apply cleanly.")
+            print(result.stderr)
+            return False
 
-def main():
-    parser = argparse.ArgumentParser(description='Apply patch with security checks')
-    parser.add_argument('patch', help='Path to patch file')
-    parser.add_argument('--target', default='.', help='Target directory')
-    args = parser.parse_args()
-    
-    try:
-        validate_patch_file(args.patch)
-        safe_apply_patch(args.patch, args.target)
-        print('Patch applied successfully')
+        # Apply the patch if dry run succeeds
+        result = subprocess.run(['patch', '-p1', '-i', 'temp.patch', '--forward'], 
+                                capture_output=True, text=True, cwd=os.path.dirname(target_file))
+        if result.returncode == 0:
+            print("Patch applied successfully.")
+            return True
+        else:
+            print("Patch application failed.")
+            print(result.stderr)
+            return False
     except Exception as e:
-        print(f'Error: {e}', file=sys.stderr)
+        print(f"Error during patch application: {e}")
+        return False
+    finally:
+        # Clean up temp file
+        if os.path.exists('temp.patch'):
+            os.remove('temp.patch')
+
+if __name__ == "__main__":
+    if len(sys.argv) < 3:
+        print("Usage: python patch.py <patch_file> <target_file>")
         sys.exit(1)
 
-if __name__ == '__main__':
-    main()+    patch_file = sys.argv[1]
+    target_file = sys.argv[2]
+
+    try:
+        with open(patch_file, 'r') as f:
+            patch_content = f.read()
+        apply_patch(patch_content, target_file)
+    except FileNotFoundError:
+        print(f"Error: Patch file {patch_file} not found.")
+        sys.exit(1)
