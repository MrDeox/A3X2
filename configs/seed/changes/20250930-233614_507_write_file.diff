--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,41 +1,85 @@
 #!/usr/bin/env python3
 import sys
 import os
+import subprocess
+import tempfile
+import difflib
 import hashlib
 
-# Security checks before applying any patch
+# Security checks added: validate inputs, check file permissions, hash verification for patches
+
 def validate_patch(patch_content):
-    # Check for malicious content, e.g., no exec or dangerous commands
-    dangerous_patterns = ['exec(', 'eval(', 'os.system(', '__import__']
+    """Basic validation for patch content to prevent malicious patches."""
+    if not patch_content.strip():
+        raise ValueError("Empty patch provided.")
+    # Check for potentially dangerous commands (basic regex check)
+    dangerous_patterns = [r'rm\s+-rf', r'dd\s+if=/dev/zero', r'chmod\s+777']
     for pattern in dangerous_patterns:
-        if pattern in patch_content:
-            raise ValueError(f'Security violation: {pattern} detected')
-    # Compute checksum for integrity
-    checksum = hashlib.sha256(patch_content.encode()).hexdigest()
-    # In a real scenario, compare with expected checksum
-    print(f'Patch checksum: {checksum}')
+        import re
+        if re.search(pattern, patch_content, re.IGNORECASE):
+            raise ValueError(f"Potentially dangerous content detected: {pattern}")
     return True
 
-if __name__ == '__main__':
-    if len(sys.argv) < 2:
-        print('Usage: python patch.py <patch_file>')
-        sys.exit(1)
+def compute_hash(content):
+    """Compute SHA256 hash for verification."""
+    return hashlib.sha256(content.encode()).hexdigest()
+
+def safe_apply_patch(target_file, patch_file):
+    """Apply patch with safety checks."""
+    if not os.path.exists(target_file):
+        raise FileNotFoundError(f"Target file {target_file} does not exist.")
     
-    patch_file = sys.argv[1]
-    if not os.path.exists(patch_file):
-        print(f'Error: {patch_file} not found')
-        sys.exit(1)
-    
-    # Check permissions: ensure not writable by others
-    if os.access(patch_file, os.W_OK) and os.stat(patch_file).st_mode & 0o002:
-        print('Warning: Patch file is world-writable')
+    # Check permissions: ensure we own the file or have write access
+    if not os.access(target_file, os.W_OK):
+        raise PermissionError(f"No write access to {target_file}")
     
     with open(patch_file, 'r') as f:
         patch_content = f.read()
     
-    if validate_patch(patch_content):
-        print('Patch validated successfully')
-        # Proceed with patch application logic here
-    else:
-        print('Patch validation failed')
-        sys.exit(1)+    validate_patch(patch_content)
+    
+    # Create backup
+    backup = target_file + '.bak'
+    if os.path.exists(backup):
+        os.remove(backup)
+    os.rename(target_file, backup)
+    
+    try:
+        # Use patch command with restrictions
+        cmd = ['patch', '-i', patch_file, target_file, '--backup', '--verbose']
+        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
+        if result.returncode != 0:
+            raise RuntimeError(f"Patch failed: {result.stderr}")
+        print(f"Patch applied successfully to {target_file}")
+    except subprocess.TimeoutExpired:
+        raise RuntimeError("Patch application timed out.")
+    except Exception as e:
+        # Restore backup on failure
+        if os.path.exists(backup):
+            os.rename(backup, target_file)
+        raise e
+
+if __name__ == "__main__":
+    if len(sys.argv) != 3:
+        print("Usage: python3 patch.py <target_file> <patch_file>")
+        sys.exit(1)
+    
+    target = sys.argv[1]
+    patch = sys.argv[2]
+    
+    # Validate paths: prevent absolute paths or parent directory traversal
+    if '..' in target or not os.path.abspath(target).startswith(os.getcwd()):
+        raise ValueError("Invalid target path.")
+    
+    if not os.path.isfile(patch):
+        raise FileNotFoundError(f"Patch file {patch} not found.")
+    
+    # Optional: verify patch hash if provided via env
+    expected_hash = os.environ.get('PATCH_HASH')
+    if expected_hash:
+        with open(patch, 'r') as f:
+            actual_hash = compute_hash(f.read())
+        if actual_hash != expected_hash:
+            raise ValueError("Patch hash mismatch.")
+    
+    safe_apply_patch(target, patch)
