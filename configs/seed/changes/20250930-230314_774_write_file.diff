--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,65 +1,52 @@
 import sys
 import os
 import subprocess
-import argparse
-import hashlib
+import tempfile
+import shutil
 
 
-def validate_patch_file(patch_path):
-    if not os.path.exists(patch_path):
-        raise FileNotFoundError(f"Patch file not found: {patch_path}")
-    if not os.path.isfile(patch_path):
-        raise ValueError(f"{patch_path} is not a file")
-    # Basic size check to avoid huge files
-    if os.path.getsize(patch_path) > 10 * 1024 * 1024:  # 10MB limit
-        raise ValueError("Patch file too large")
-    # Check if it's a text file (simple heuristic)
-    with open(patch_path, 'rb') as f:
-        content = f.read(512)
-        if b'\x00' in content:
-            raise ValueError("Patch file appears to be binary, not text")
+def validate_patch(patch_file):
+    if not os.path.exists(patch_file):
+        raise FileNotFoundError(f"Patch file {patch_file} not found.")
+    with open(patch_file, 'r') as f:
+        content = f.read()
+    # Basic validation: check for suspicious commands
+    suspicious_patterns = ['rm -rf', 'exec', ';', '|']
+    for pattern in suspicious_patterns:
+        if pattern in content:
+            raise ValueError(f"Suspicious pattern '{pattern}' found in patch.")
+    return True
 
 
-def compute_file_hash(file_path):
-    hasher = hashlib.sha256()
-    with open(file_path, 'rb') as f:
-        for chunk in iter(lambda: f.read(4096), b''):
-            hasher.update(chunk)
-    return hasher.hexdigest()
-
-
-def safe_apply_patch(patch_path, target_dir='.', strip=0):
-    validate_patch_file(patch_path)
+def apply_patch(patch_file, target_dir='.'):
+    # Security checks
+    if not os.path.exists(target_dir):
+        raise FileNotFoundError(f"Target directory {target_dir} not found.")
     
-    # Ensure target_dir is safe (no traversal)
-    abs_target = os.path.abspath(target_dir)
-    if not abs_target.startswith(os.getcwd()):
-        raise ValueError("Target directory outside current working directory")
+    validate_patch(patch_file)
     
-    # Run patch command with safety
-    cmd = ['patch', '-p', str(strip), '-d', abs_target, '-i', patch_path]
-    try:
-        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
-        if result.returncode != 0:
-            raise subprocess.CalledProcessError(result.returncode, cmd, result.stdout, result.stderr)
-        print("Patch applied successfully.")
-        print(result.stdout)
-    except subprocess.CalledProcessError as e:
-        print(f"Patch failed: {e}")
-        print(e.stderr)
-        raise
-
+    # Use temporary directory for safe application
+    with tempfile.TemporaryDirectory() as temp_dir:
+        shutil.copytree(target_dir, temp_dir, dirs_exist_ok=True)
+        
+        cmd = ['patch', '-p1', '-d', temp_dir]
+        try:
+            result = subprocess.run(cmd, input=open(patch_file, 'rb').read(), check=True, capture_output=True, text=False)
+            print("Patch applied successfully in temp dir.")
+            # Optionally, copy back or verify
+            shutil.rmtree(temp_dir)
+        except subprocess.CalledProcessError as e:
+            print(f"Patch failed: {e}")
+            raise
 
 if __name__ == '__main__':
-    parser = argparse.ArgumentParser(description='Safely apply patches')
-    parser.add_argument('patch_file', help='Path to the patch file')
-    parser.add_argument('-d', '--directory', default='.', help='Target directory')
-    parser.add_argument('-p', '--strip', type=int, default=0, help='Strip level')
-    
-    args = parser.parse_args()
-    
+    if len(sys.argv) < 2:
+        print("Usage: python patch.py <patch_file> [target_dir]")
+        sys.exit(1)
+    patch_file = sys.argv[1]
+    target_dir = sys.argv[2] if len(sys.argv) > 2 else '.'
     try:
-        safe_apply_patch(args.patch_file, args.directory, args.strip)
+        apply_patch(patch_file, target_dir)
     except Exception as e:
-        print(f"Error: {e}", file=sys.stderr)
+        print(f"Error: {e}")
         sys.exit(1)
