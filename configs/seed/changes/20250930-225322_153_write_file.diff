--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,73 +1,77 @@
 import sys
 import os
 import subprocess
-import argparse
+import re
+import hashlib
 
-
-def validate_path(path):
-    """Valida e sanitiza o caminho para prevenir directory traversal."""
-    if not path:
-        raise ValueError("Caminho não pode ser vazio.")
-    # Converte para caminho absoluto e resolve symlinks
-    abs_path = os.path.abspath(os.path.realpath(path))
-    # Verifica se está dentro do diretório atual ou especificado (aqui, assume cwd)
-    if not abs_path.startswith(os.getcwd()):
-        raise ValueError("Caminho fora do diretório permitido.")
-    return abs_path
-
-
-def check_file_permissions(file_path, mode='r'):
-    """Verifica permissões do arquivo."""
-    if not os.path.exists(file_path):
-        raise FileNotFoundError(f"Arquivo não encontrado: {file_path}")
-    if mode == 'r' and not os.access(file_path, os.R_OK):
-        raise PermissionError(f"Sem permissão de leitura: {file_path}")
-    if mode == 'w' and not os.access(file_path, os.W_OK):
-        raise PermissionError(f"Sem permissão de escrita: {file_path}")
+# Security checks
+def validate_diff_content(diff_content):
+    # Basic validation: ensure it's a unified diff
+    if not re.search(r'^---\s', diff_content, re.MULTILINE):
+        raise ValueError('Invalid diff format: missing --- header')
+    if not re.search(r'^\+\+\+\s', diff_content, re.MULTILINE):
+        raise ValueError('Invalid diff format: missing +++ header')
+    # Check for suspicious patterns, e.g., exec or dangerous commands
+    dangerous_patterns = [r'\bexec\b', r'\bsystem\b', r'\brm\s+-rf\b']
+    for pattern in dangerous_patterns:
+        if re.search(pattern, diff_content, re.IGNORECASE):
+            raise ValueError(f'Suspicious pattern detected: {pattern}')
     return True
 
+def compute_file_hash(filepath):
+    hasher = hashlib.sha256()
+    with open(filepath, 'rb') as f:
+        for chunk in iter(lambda: f.read(4096), b''):
+            hasher.update(chunk)
+    return hasher.hexdigest()
 
-def apply_secure_patch(patch_file, target_dir, strip_level=1):
-    """Aplica o patch de forma segura usando subprocess sem shell."""
-    # Validações
-    patch_path = validate_path(patch_file)
-    target_path = validate_path(target_dir)
-    check_file_permissions(patch_path, 'r')
-    check_file_permissions(target_path, 'w')
-    
-    # Comando seguro: lista de argumentos, shell=False
-    cmd = [
-        'patch',
-        f'-p{strip_level}',
-        '-i', patch_path,
-        '--directory', target_path,
-        '--backup',  # Cria backup se possível
-        '--verbose'  # Para logging
-    ]
-    
-    try:
-        result = subprocess.run(cmd, check=True, capture_output=True, text=True)
-        print("Patch aplicado com sucesso.")
-        print(result.stdout)
-    except subprocess.CalledProcessError as e:
-        print(f"Erro ao aplicar patch: {e}")
-        print(e.stderr)
-        sys.exit(1)
-    except FileNotFoundError:
-        print("Comando 'patch' não encontrado. Instale o utilitário patch.")
+def safe_apply_patch(patch_file, target_dir='.', strip=0):
+    # Read and validate patch
+    with open(patch_file, 'r') as f:
+        diff_content = f.read()
+    validate_diff_content(diff_content)
+
+    # Ensure target dir exists and is writable
+    if not os.path.exists(target_dir):
+        os.makedirs(target_dir)
+    if not os.access(target_dir, os.W_OK):
+        raise PermissionError(f'No write permission in {target_dir}')
+
+    # Run patch with safety options
+    cmd = ['patch', '-p' + str(strip), '-d', target_dir, '--dry-run']
+    result = subprocess.run(cmd + [patch_file], capture_output=True, text=True)
+    if result.returncode != 0:
+        print('Dry run failed, potential issues:')
+        print(result.stderr)
+        return False
+
+    # If dry run ok, apply for real
+    cmd[-1] = patch_file  # Remove --dry-run
+    cmd.remove('--dry-run')
+    result = subprocess.run(cmd, capture_output=True, text=True)
+    if result.returncode == 0:
+        print('Patch applied successfully')
+        # Optionally verify hashes or something
+        return True
+    else:
+        print('Failed to apply patch:')
+        print(result.stderr)
+        return False
+
+if __name__ == '__main__':
+    if len(sys.argv) < 2:
+        print('Usage: python patch.py <patchfile> [target_dir]')
         sys.exit(1)
 
+    patch_file = sys.argv[1]
+    target_dir = sys.argv[2] if len(sys.argv) > 2 else '.'
 
-if __name__ == "__main__":
-    parser = argparse.ArgumentParser(description="Aplica patches de forma segura.")
-    parser.add_argument('patch_file', help="Arquivo de patch")
-    parser.add_argument('target_dir', help="Diretório alvo")
-    parser.add_argument('-p', '--strip', type=int, default=1, help="Nível de strip")
-    
-    args = parser.parse_args()
-    
+    if not os.path.exists(patch_file):
+        print(f'Patch file {patch_file} not found')
+        sys.exit(1)
+
     try:
-        apply_secure_patch(args.patch_file, args.target_dir, args.strip)
-    except (ValueError, FileNotFoundError, PermissionError) as e:
-        print(f"Erro de validação: {e}")
+        safe_apply_patch(patch_file, target_dir)
+    except Exception as e:
+        print(f'Security or application error: {e}')
         sys.exit(1)
