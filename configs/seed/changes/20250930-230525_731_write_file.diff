--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -2,92 +2,58 @@
 import sys
 import os
 import subprocess
-import argparse
-import hashlib
-import tempfile
+import re
 
 # Security checks
-def validate_patch_file(patch_path):
-    if not os.path.exists(patch_path):
-        raise FileNotFoundError(f"Patch file not found: {patch_path}")
-    if not os.path.isfile(patch_path):
-        raise ValueError(f"{patch_path} is not a file")
-    # Check file size to prevent huge files
-    if os.path.getsize(patch_path) > 10 * 1024 * 1024:  # 10MB limit
-        raise ValueError("Patch file too large")
-    # Basic content validation: ensure it's text and looks like a diff
-    with open(patch_path, 'r', encoding='utf-8', errors='ignore') as f:
-        content = f.read(1024)  # Read first 1KB
-        if not any(line.startswith(('---', '+++', '@@', 'diff')) for line in content.splitlines()):
-            raise ValueError("Invalid patch format")
-    return True
+def validate_patch_content(patch_content):
+    # Check for dangerous commands
+    dangerous_patterns = [
+        r'rm\s+.*',
+        r'dd\s+if=',
+        r'mkfs',
+        r'format',
+        r'chmod\s+.*777',
+        r'sudo\s+',
+    ]
+    for pattern in dangerous_patterns:
+        if re.search(pattern, patch_content, re.IGNORECASE):
+            return False, f"Dangerous pattern detected: {pattern}"
+    return True, "Patch is safe"
 
-def compute_file_hash(file_path):
-    hasher = hashlib.sha256()
-    with open(file_path, 'rb') as f:
-        for chunk in iter(lambda: f.read(4096), b''):
-            hasher.update(chunk)
-    return hasher.hexdigest()
+def apply_patch_safely(patch_file, target_dir):
+    with open(patch_file, 'r') as f:
+        patch_content = f.read()
+    
+    is_safe, message = validate_patch_content(patch_content)
+    if not is_safe:
+        print(f"Security check failed: {message}")
+        return 1
+    
+    print("Security checks passed.")
+    
+    # Proceed with patch application
+    cmd = ['patch', '-p1', '-d', target_dir]
+    result = subprocess.run(cmd, input=patch_content.encode(), capture_output=True)
+    if result.returncode != 0:
+        print(f"Patch failed: {result.stderr.decode()}")
+        return 1
+    print("Patch applied successfully.")
+    return 0
 
-def backup_file(file_path):
-    backup_path = file_path + '.bak'
-    if os.path.exists(backup_path):
-        os.remove(backup_path)
-    os.rename(file_path, backup_path)
-    return backup_path
-
-def main():
-    parser = argparse.ArgumentParser(description='Apply patches with security checks')
-    parser.add_argument('patch_file', help='Path to the patch file')
-    parser.add_argument('target_file', nargs='?', default=None, help='Target file to patch (optional, inferred from patch)')
-    parser.add_argument('--dry-run', action='store_true', help='Dry run without applying')
-    parser.add_argument('--no-backup', action='store_true', help='Do not create backup')
-
-    args = parser.parse_args()
-
-    # Security: Validate inputs
-    if not args.patch_file:
-        raise ValueError("Patch file is required")
-    validate_patch_file(args.patch_file)
-
-    # Determine target file if not provided
-    if not args.target_file:
-        with open(args.patch_file, 'r') as f:
-            for line in f:
-                if line.startswith('--- '):
-                    args.target_file = line[4:].strip().lstrip('a/')
-                    break
-        if not args.target_file:
-            raise ValueError("Could not infer target file from patch")
-
-    # Security: Check permissions
-    if not os.access(args.target_file, os.W_OK):
-        raise PermissionError(f"No write permission for {args.target_file}")
-
-    # Compute hash before applying
-    original_hash = compute_file_hash(args.target_file)
-
-    if not args.no_backup:
-        backup_file(args.target_file)
-
-    # Apply patch
-    cmd = ['patch', '-p1', '--input=' + args.patch_file, args.target_file]
-    if args.dry_run:
-        cmd.append('--dry-run')
-
-    try:
-        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
-        print("Patch applied successfully.")
-        if not args.dry_run:
-            new_hash = compute_file_hash(args.target_file)
-            if original_hash == new_hash:
-                print("Warning: File unchanged after patch.")
-    except subprocess.CalledProcessError as e:
-        print(f"Patch failed: {e.stderr}")
-        if not args.no_backup and os.path.exists(args.target_file + '.bak'):
-            os.rename(args.target_file + '.bak', args.target_file)
-            print("Restored from backup.")
+if __name__ == "__main__":
+    if len(sys.argv) != 3:
+        print("Usage: python patch.py <patch_file> <target_dir>")
         sys.exit(1)
-
-if __name__ == '__main__':
-    main()+    
+    patch_file = sys.argv[1]
+    target_dir = sys.argv[2]
+    
+    if not os.path.exists(patch_file):
+        print(f"Patch file not found: {patch_file}")
+        sys.exit(1)
+    
+    if not os.path.isdir(target_dir):
+        print(f"Target directory not found: {target_dir}")
+        sys.exit(1)
+    
+    sys.exit(apply_patch_safely(patch_file, target_dir))