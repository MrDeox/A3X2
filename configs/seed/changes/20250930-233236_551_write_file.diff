--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,79 +1,75 @@
 #!/usr/bin/env python3
 import sys
 import os
+import subprocess
+import tempfile
+import shutil
 import difflib
-import subprocess
 
+# Security checks
+def validate_patch_safety(diff_content):
+    risky_patterns = [
+        r'rm\s+-rf',
+        r'dd\s+if=/dev/zero',
+        r'chmod\s+777',
+        r'exec\s+',
+        r'sudo\s+',
+    ]
+    for pattern in risky_patterns:
+        if re.search(pattern, diff_content, re.IGNORECASE):
+            return False, f"Risky command detected: {pattern}"
+    return True, "Safe"
 
-def assess_patch_risk(patch_content):
-    """Avalia o risco do patch antes de aplicar."""
-    lines = patch_content.splitlines()
-    risk_score = 0
-    high_risk_keywords = ['rm -rf', 'del /f /q', 'format', 'mkfs', 'dd if=/dev/zero']
-    
-    for line in lines:
-        line_lower = line.lower()
-        if any(keyword in line_lower for keyword in high_risk_keywords):
-            risk_score += 10
-        if 'exec' in line_lower or 'eval' in line_lower:
-            risk_score += 5
-    
-    if risk_score >= 10:
-        return 'high'
-    elif risk_score >= 5:
-        return 'medium'
-    else:
-        return 'low'
+import re
 
+def apply_patch_safely(patch_file, target_dir):
+    if not os.path.exists(target_dir):
+        os.makedirs(target_dir)
+    if not os.path.isdir(target_dir):
+        return False, "Target is not a directory"
 
-def apply_patch_safely(file_path, patch_content):
-    """Aplica o patch apenas se o risco for baixo."""
-    risk = assess_patch_risk(patch_content)
-    if risk == 'high':
-        print(f"Patch rejected due to high risks: {risk}")
-        return False
-    
-    # Backup do arquivo original
-    backup_path = file_path + '.backup'
-    if os.path.exists(file_path):
-        os.rename(file_path, backup_path)
-    
+    with open(patch_file, 'r') as f:
+        diff_content = f.read()
+
+    is_safe, msg = validate_patch_safety(diff_content)
+    if not is_safe:
+        return False, msg
+
+    # Create a backup
+    backup_dir = target_dir + '.backup'
+    if os.path.exists(backup_dir):
+        shutil.rmtree(backup_dir)
+    shutil.copytree(target_dir, backup_dir)
+
     try:
-        # Simular aplicação do patch (exemplo simples com difflib)
-        with open(backup_path, 'r') as f:
-            original = f.read()
-        
-        # Aplicar patch logicamente (simplificado)
-        # Em um caso real, usaria patch ou similar
-        new_content = apply_diff(original, patch_content)
-        
-        with open(file_path, 'w') as f:
-            f.write(new_content)
-        
-        print(f"Patch applied successfully with risk level: {risk}")
-        return True
+        result = subprocess.run(['patch', '-p1', '-d', target_dir], input=diff_content.encode(), capture_output=True)
+        if result.returncode == 0:
+            return True, "Patch applied successfully"
+        else:
+            # Revert backup
+            shutil.rmtree(target_dir)
+            shutil.copytree(backup_dir, target_dir)
+            return False, f"Patch failed: {result.stderr.decode()}"
     except Exception as e:
-        print(f"Failed to apply patch: {e}")
-        # Restaurar backup
-        if os.path.exists(backup_path):
-            os.rename(backup_path, file_path)
-        return False
-
-
-def apply_diff(original, patch):
-    """Aplica diff simples usando difflib."""
-    # Implementação simplificada
-    return original + "\n# Patched content added for safety\n"
+        # Revert
+        shutil.rmtree(target_dir)
+        shutil.copytree(backup_dir, target_dir)
+        return False, str(e)
 
 if __name__ == "__main__":
-    if len(sys.argv) < 3:
-        print("Usage: python patch.py <file> <patch_file>")
+    if len(sys.argv) != 3:
+        print("Usage: python3 patch.py <patch_file> <target_dir>")
         sys.exit(1)
-    
-    file_path = sys.argv[1]
-    patch_file = sys.argv[2]
-    
-    with open(patch_file, 'r') as f:
-        patch_content = f.read()
-    
-    apply_patch_safely(file_path, patch_content)
+
+    patch_file = sys.argv[1]
+    target_dir = os.path.abspath(sys.argv[2])
+
+    # Additional security: ensure target_dir is under a safe root
+    safe_root = '/home/user/projects'  # Configure this
+    if not target_dir.startswith(safe_root):
+        print("Error: Target directory outside safe root")
+        sys.exit(1)
+
+    success, message = apply_patch_safely(patch_file, target_dir)
+    print(message)
+    sys.exit(0 if success else 1)
