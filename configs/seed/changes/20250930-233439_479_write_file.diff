--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,36 +1,68 @@
 #!/usr/bin/env python3
 import sys
 import os
+import subprocess
 import re
+import hashlib
 
-# Security checks function
-def security_check_patch(patch_content):
-    dangerous_patterns = [
-        r'rm\s+-rf',
-        r'dd\s+if=/dev/zero',
-        r'exec\s+.*bash',
-        # Add more patterns as needed
-    ]
-    for pattern in dangerous_patterns:
-        if re.search(pattern, patch_content, re.IGNORECASE):
-            return False, f"Dangerous pattern detected: {pattern}"
-    return True, "Patch is safe"
+class SecurePatcher:
+    def __init__(self):
+        self.risk_keywords = ['rm -rf', 'del /f', 'format', 'exec', ';', '|', '&', 'sudo', 'chmod +x']
+        self.max_patch_size = 10240  # 10KB limit
 
-# Example usage in patching logic
-if __name__ == "__main__":
-    if len(sys.argv) < 2:
-        print("Usage: python patch.py <patch_file>")
+    def validate_patch(self, patch_content):
+        if len(patch_content) > self.max_patch_size:
+            return False, 'Patch too large'
+        for keyword in self.risk_keywords:
+            if re.search(re.escape(keyword), patch_content, re.IGNORECASE):
+                return False, f'Risky keyword detected: {keyword}'
+        # Check hash or signature if needed
+        return True, 'Valid'
+
+    def backup_file(self, target_file):
+        if os.path.exists(target_file):
+            backup = target_file + '.bak'
+            os.rename(target_file, backup)
+            return backup
+        return None
+
+    def apply_secure_patch(self, patch_content, target_file):
+        valid, msg = self.validate_patch(patch_content)
+        if not valid:
+            print(f'Security check failed: {msg}')
+            return False
+
+        backup = self.backup_file(target_file)
+        print(f'Backup created: {backup}')
+
+        try:
+            result = subprocess.run(
+                ['patch', '-p0', '--backup', '--verbose', target_file],
+                input=patch_content,
+                text=True,
+                capture_output=True,
+                check=True
+            )
+            print('Patch applied successfully')
+            return True
+        except subprocess.CalledProcessError as e:
+            print(f'Patch application failed: {e}')
+            if backup:
+                os.rename(backup, target_file)
+                print('Restored from backup')
+            return False
+
+if __name__ == '__main__':
+    if len(sys.argv) < 3:
+        print('Usage: python patch.py <patch_file> <target_file>')
         sys.exit(1)
+
     patch_file = sys.argv[1]
-    if not os.path.exists(patch_file):
-        print("Patch file not found.")
-        sys.exit(1)
+    target_file = sys.argv[2]
+
     with open(patch_file, 'r') as f:
         patch_content = f.read()
-    is_safe, message = security_check_patch(patch_content)
-    if not is_safe:
-        print(f"Security check failed: {message}")
-        sys.exit(1)
-    print("Security check passed. Applying patch...")
-    # Placeholder for actual patch application
-    print("Patch applied successfully.")+
+    patcher = SecurePatcher()
+    success = patcher.apply_secure_patch(patch_content, target_file)
+    sys.exit(0 if success else 1)
