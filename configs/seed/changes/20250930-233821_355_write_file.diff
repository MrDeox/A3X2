--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,103 +1,84 @@
 #!/usr/bin/env python3
 import sys
 import os
+import subprocess
+import tempfile
 import shutil
-import tempfile
-import subprocess
+import hashlib
+import re
 
-def apply_patch(patch_content, target_file):
-    # Security check 1: Ensure target file exists and is a regular file
+# Security checks
+def validate_patch_content(patch_content):
+    # Check for dangerous patterns like exec, eval, system calls
+    dangerous_patterns = [
+        r'eval\(', r'exec\(', r'__import__\(', r'subprocess\.', r'os\.(system|pop en|popen)',
+        r'open\(', r'file\(', r'\$\(',
+    ]
+    for pattern in dangerous_patterns:
+        if re.search(pattern, patch_content, re.IGNORECASE):
+            return False, f"Dangerous pattern detected: {pattern}"
+    # Check patch size limit
+    if len(patch_content) > 10000:  # Arbitrary limit
+        return False, "Patch too large"
+    return True, "Valid"
+
+def compute_hash(content):
+    return hashlib.sha256(content.encode()).hexdigest()
+
+def safe_apply_patch(patch_file, target_file):
+    # Validate target file exists and is writable
     if not os.path.exists(target_file):
-        print(f"Error: Target file {target_file} does not exist.")
-        sys.exit(1)
-    if not os.path.isfile(target_file):
-        print(f"Error: {target_file} is not a regular file.")
+        raise ValueError(f"Target file {target_file} does not exist")
+    if not os.access(target_file, os.W_OK):
+        raise ValueError(f"Target file {target_file} is not writable")
+
+    with open(patch_file, 'r') as f:
+        patch_content = f.read()
+
+    is_valid, msg = validate_patch_content(patch_content)
+    if not is_valid:
+        raise ValueError(msg)
+
+    # Backup original
+    original_hash = compute_hash(open(target_file).read())
+    backup_file = target_file + '.backup.' + original_hash[:8]
+    shutil.copy2(target_file, backup_file)
+
+    # Apply patch safely
+    try:
+        result = subprocess.run(['patch', '-p1', '--backup', '--verbose', target_file], 
+                                input=patch_content.encode(), 
+                                capture_output=True, check=True)
+        print(f"Patch applied successfully: {result.stdout.decode()}")
+        return True
+    except subprocess.CalledProcessError as e:
+        print(f"Patch failed: {e.stderr.decode()}")
+        # Restore backup
+        shutil.copy2(backup_file, target_file)
+        return False
+    except Exception as e:
+        print(f"Unexpected error: {e}")
+        shutil.copy2(backup_file, target_file)
+        return False
+
+if __name__ == '__main__':
+    if len(sys.argv) != 3:
+        print("Usage: python3 patch.py <patch_file> <target_file>")
         sys.exit(1)
 
-    # Security check 2: Check write permissions
-    if not os.access(target_file, os.W_OK):
-        print(f"Error: No write permission for {target_file}.")
-        sys.exit(1)
+    patch_file = sys.argv[1]
+    target_file = sys.argv[2]
 
-    # Security check 3: Create backup of original file
-    backup_file = target_file + ".backup"
-    try:
-        shutil.copy2(target_file, backup_file)
-        print(f"Backup created: {backup_file}")
-    except Exception as e:
-        print(f"Error creating backup: {e}")
-        sys.exit(1)
-
-    # Security check 4: Basic validation of patch content
-    if not patch_content.strip().startswith(('diff --git', '--- ')):
-        print("Error: Invalid patch format. Patch must start with 'diff' or '---'.")
-        sys.exit(1)
-
-    # Security check 5: Limit patch size to prevent large inputs
-    if len(patch_content) > 100000:  # 100KB limit
-        print("Error: Patch too large.")
-        sys.exit(1)
-
-    # Apply the patch using subprocess in a controlled manner
-    with tempfile.NamedTemporaryFile(mode='w', suffix='.patch', delete=False) as f:
-        f.write(patch_content)
-        temp_patch = f.name
-
-    try:
-        # Run patch command with limited environment
-        env = os.environ.copy()
-        env['PATH'] = '/usr/bin:/bin'  # Restrict PATH
-        result = subprocess.run(
-            ['patch', '-p1', target_file],
-            input=patch_content,
-            capture_output=True,
-            text=True,
-            env=env,
-            timeout=30  # Timeout to prevent hangs
-        )
-        if result.returncode != 0:
-            print("Patch application failed:")
-            print(result.stderr)
-            # Restore backup on failure
-            shutil.copy2(backup_file, target_file)
-            print("Restored from backup.")
-            sys.exit(1)
-        else:
-            print("Patch applied successfully.")
-            os.chmod(target_file, 0o644)  # Set safe permissions
-    except subprocess.TimeoutExpired:
-        print("Patch application timed out.")
-        shutil.copy2(backup_file, target_file)
-        sys.exit(1)
-    except Exception as e:
-        print(f"Error applying patch: {e}")
-        shutil.copy2(backup_file, target_file)
-        sys.exit(1)
-    finally:
-        if os.path.exists(temp_patch):
-            os.unlink(temp_patch)
-        if os.path.exists(backup_file):
-            # Optionally keep backup, or remove after success
-            pass  # Keep for now
-
-if __name__ == "__main__":
-    if len(sys.argv) != 3:
-        print("Usage: python patch.py <target_file> <patch_file>")
-        sys.exit(1)
-
-    target_file = sys.argv[1]
-    patch_file = sys.argv[2]
-
-    # Security check 6: Validate patch file
     if not os.path.exists(patch_file):
-        print(f"Error: Patch file {patch_file} does not exist.")
+        print(f"Patch file {patch_file} does not exist")
         sys.exit(1)
 
     try:
-        with open(patch_file, 'r') as f:
-            patch_content = f.read()
+        success = safe_apply_patch(patch_file, target_file)
+        sys.exit(0 if success else 1)
+    except ValueError as e:
+        print(f"Security validation failed: {e}")
+        sys.exit(1)
     except Exception as e:
-        print(f"Error reading patch file: {e}")
+        print(f"Error: {e}")
         sys.exit(1)
-
-    apply_patch(patch_content, target_file)
