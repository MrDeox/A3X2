--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,84 +1,89 @@
 #!/usr/bin/env python3
 import sys
 import os
-import difflib
-import argparse
+import re
+import subprocess
+from difflib import SequenceMatcher
 
 
-def safe_path_check(path):
-    abs_path = os.path.abspath(path)
-    # Prevent patching sensitive directories
-    forbidden_dirs = ['/etc', '/bin', '/usr', '/var', '/root', '/home']  # Customize as needed
-    for forbidden in forbidden_dirs:
-        if abs_path.startswith(forbidden):
-            return False
-    return True
+def check_security_patch(patch_content):
+    """Check patch for potential security risks."""
+    dangerous_patterns = [
+        r'os\.(system|pop(?:en|en2))\s*\(',  # os.system, os.popen, etc.
+        r'eval\s*\(',
+        r'exec\s*\(',
+        r'__import__\s*\(',
+        r'subprocess\.(call|Popen)\s*\(',
+        r'rm\s+[-rf]',  # rm -rf
+        r'dd\s+if=',  # potential overwrite
+        r'chmod\s+[0-7]+\s+/',  # changing permissions broadly
+    ]
+    for pattern in dangerous_patterns:
+        if re.search(pattern, patch_content, re.IGNORECASE):
+            return False, f"Dangerous pattern detected: {pattern}"
+    return True, "Patch appears safe"
 
 
-def apply_secure_patch(target_file, patch_str, strip_level=0):
-    if not safe_path_check(target_file):
-        print(f"Security error: Unsafe path {target_file}", file=sys.stderr)
+def apply_patch_safely(patch_file, target_dir='.'):
+    """Apply a patch with security checks."""
+    if not os.path.exists(patch_file):
+        print(f"Patch file {patch_file} not found.")
         return False
 
-    if not os.path.exists(target_file):
-        print(f"Error: File {target_file} does not exist.", file=sys.stderr)
-        return False
+    with open(patch_file, 'r') as f:
+        patch_content = f.read()
 
+    is_safe, message = check_security_patch(patch_content)
+    print(message)
+    if not is_safe:
+        response = input("Do you want to apply anyway? (y/N): ")
+        if response.lower() != 'y':
+            return False
+
+    # Change to target directory
+    original_cwd = os.getcwd()
     try:
-        with open(target_file, 'r') as f:
-            original_lines = f.readlines()
+        os.chdir(target_dir)
+        # Use patch command with restrictions
+        result = subprocess.run(
+            ['patch', '-p1', '--dry-run'],
+            input=patch_content.encode(),
+            capture_output=True,
+            text=True
+        )
+        if result.returncode != 0:
+            print("Dry run failed, patch may not apply cleanly.")
+            return False
 
-        # Simple unified diff parsing (basic implementation)
-        patch_lines = patch_str.strip().split('\n')
-        new_lines = original_lines[:]
-        i = 0
-        while i < len(patch_lines):
-            line = patch_lines[i]
-            if line.startswith('@@ '):
-                # Parse hunk header: @@ -start,count +start,count @@
-                header = line[3:-1].split(' ')
-                old_start = int(header[0].split(',')[0][1:]) - 1
-                new_start = int(header[1].split(',')[0][1:]) - 1
-                hunk_size = 0
-                j = i + 1
-                hunk = []
-                while j < len(patch_lines) and not patch_lines[j].startswith('@@'):
-                    hunk.append(patch_lines[j])
-                    if patch_lines[j].startswith((' ', '+', '-')):
-                        hunk_size += 1
-                    j += 1
-                # Apply hunk (simplified, assumes no context mismatches)
-                del new_lines[old_start:old_start + hunk_size]
-                for h in hunk:
-                    if not h.startswith('-'):
-                        new_lines.insert(old_start, h + '\n')
-                        old_start += 1
-                i = j
+        # If dry run ok, apply for real
+        confirm = input("Dry run successful. Apply patch? (y/N): ")
+        if confirm.lower() == 'y':
+            result = subprocess.run(
+                ['patch', '-p1'],
+                input=patch_content.encode(),
+                capture_output=True,
+                text=True
+            )
+            if result.returncode == 0:
+                print("Patch applied successfully.")
+                return True
             else:
-                i += 1
-
-        with open(target_file, 'w') as f:
-            f.writelines(new_lines)
-        print(f"Patch applied successfully to {target_file}")
-        return True
-    except Exception as e:
-        print(f"Error applying patch: {e}", file=sys.stderr)
-        return False
+                print(f"Failed to apply patch: {result.stderr}")
+                return False
+        else:
+            print("Patch not applied.")
+            return False
+    finally:
+        os.chdir(original_cwd)
 
 
 if __name__ == '__main__':
-    parser = argparse.ArgumentParser(description='Apply secure patches to files')
-    parser.add_argument('target', help='Target file to patch')
-    parser.add_argument('patchfile', help='Patch file or stdin')
-    parser.add_argument('-p', '--strip', type=int, default=0, help='Strip level')
+    if len(sys.argv) < 2:
+        print("Usage: python3 patch.py <patch_file> [target_dir]")
+        sys.exit(1)
 
-    args = parser.parse_args()
+    patch_file = sys.argv[1]
+    target_dir = sys.argv[2] if len(sys.argv) > 2 else '.'
 
-    if args.patchfile == '-':
-        patch_content = sys.stdin.read()
-    else:
-        with open(args.patchfile, 'r') as f:
-            patch_content = f.read()
-
-    success = apply_secure_patch(args.target, patch_content, args.strip)
+    success = apply_patch_safely(patch_file, target_dir)
     sys.exit(0 if success else 1)
