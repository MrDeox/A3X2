--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -2,89 +2,84 @@
 import sys
 import os
 import subprocess
-import tempfile
-import hashlib
 
 
-def validate_patch(patch_content):
-    # Basic validation: check if it's a valid diff
-    if not patch_content.startswith(('---', '+++', 'diff ')):
-        return False, "Invalid patch format"
-    # Check for malicious content, e.g., no exec or dangerous commands
-    dangerous_keywords = ['exec(', 'eval(', 'os.system', 'subprocess.call']
-    for keyword in dangerous_keywords:
-        if keyword in patch_content:
-            return False, f"Dangerous keyword detected: {keyword}"
-    return True, "Valid"
+def validate_inputs(file_path, patch_path):
+    """Validações de segurança básicas para os inputs."""
+    # Verificar se os argumentos foram fornecidos
+    if not file_path or not patch_path:
+        raise ValueError("File path and patch path are required.")
+
+    # Verificar existência dos arquivos
+    if not os.path.exists(file_path):
+        raise FileNotFoundError(f"Target file does not exist: {file_path}")
+    if not os.path.exists(patch_path):
+        raise FileNotFoundError(f"Patch file does not exist: {patch_path}")
+
+    # Verificar permissões no arquivo alvo (leitura e escrita)
+    if not os.access(file_path, os.R_OK | os.W_OK):
+        raise PermissionError(f"Insufficient permissions for {file_path}")
+
+    # Verificar se o patch não é muito grande (limite de segurança, ex: 1MB)
+    if os.path.getsize(patch_path) > 1024 * 1024:
+        raise ValueError("Patch file too large, potential security risk.")
+
+    # Evitar caminhos absolutos ou com '..' para prevenir directory traversal
+    if os.path.isabs(file_path) or '..' in os.path.normpath(file_path):
+        raise ValueError("Invalid target file path: potential traversal attempt.")
+    if os.path.isabs(patch_path) or '..' in os.path.normpath(patch_path):
+        raise ValueError("Invalid patch file path: potential traversal attempt.")
+
+    # Verificar se o patch contém comandos perigosos (básico: checar por ; ou |)
+    with open(patch_path, 'r') as f:
+        content = f.read()
+        if any(cmd in content for cmd in [';', '|', '&', '`']):
+            raise ValueError("Patch contains suspicious shell metacharacters.")
 
 
-def compute_file_hash(filepath):
-    hasher = hashlib.sha256()
-    with open(filepath, 'rb') as f:
-        for chunk in iter(lambda: f.read(4096), b''):
-            hasher.update(chunk)
-    return hasher.hexdigest()
-
-
-def apply_secure_patch(patch_file, target_file, backup=True):
-    if not os.path.exists(target_file):
-        print(f"Error: Target file {target_file} does not exist.")
-        return False
-
-    if not os.access(target_file, os.R_OK | os.W_OK):
-        print(f"Error: Insufficient permissions for {target_file}")
-        return False
-
-    # Read patch content
-    with open(patch_file, 'r') as f:
-        patch_content = f.read()
-
-    is_valid, msg = validate_patch(patch_content)
-    if not is_valid:
-        print(f"Patch validation failed: {msg}")
-        return False
-
-    original_hash = compute_file_hash(target_file)
-
-    if backup:
-        backup_file = target_file + '.bak'
-        os.rename(target_file, backup_file)
-
+def apply_patch_safely(file_path, patch_path):
+    """Aplica o patch de forma segura usando subprocess."""
     try:
-        # Use subprocess to apply patch safely
-        cmd = ['patch', '-p1', '--input=' + patch_file, target_file]
-        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
-        print(f"Patch applied successfully: {result.stdout}")
+        with open(patch_path, 'rb') as patch_file:
+            result = subprocess.run(
+                ['patch', '-p1', file_path],
+                input=patch_file.read(),
+                capture_output=True,
+                text=False,
+                check=True
+            )
         return True
     except subprocess.CalledProcessError as e:
-        print(f"Patch application failed: {e.stderr}")
-        if backup:
-            os.rename(backup_file, target_file)  # Restore backup
+        print(f"Patch application failed: {e}")
+        print(f"Stdout: {e.stdout.decode() if e.stdout else ''}")
+        print(f"Stderr: {e.stderr.decode() if e.stderr else ''}")
         return False
     except Exception as e:
         print(f"Unexpected error: {e}")
-        if backup:
-            os.rename(backup_file, target_file)
         return False
 
 
-if __name__ == '__main__':
-    if len(sys.argv) < 3:
-        print("Usage: python patch.py <patch_file> <target_file> [--no-backup]")
+def main():
+    if len(sys.argv) != 3:
+        print("Usage: python patch.py <target_file> <patch_file>")
         sys.exit(1)
 
-    patch_file = sys.argv[1]
-    target_file = sys.argv[2]
-    backup = '--no-backup' not in sys.argv
+    file_path = sys.argv[1]
+    patch_path = sys.argv[2]
 
-    if not os.path.exists(patch_file):
-        print(f"Error: Patch file {patch_file} does not exist.")
+    try:
+        validate_inputs(file_path, patch_path)
+        print(f"Validating inputs... OK")
+        if apply_patch_safely(file_path, patch_path):
+            print("Patch applied successfully.")
+            sys.exit(0)
+        else:
+            print("Patch application failed.")
+            sys.exit(1)
+    except Exception as e:
+        print(f"Security check failed: {e}")
         sys.exit(1)
 
-    success = apply_secure_patch(patch_file, target_file, backup)
-    if success:
-        new_hash = compute_file_hash(target_file)
-        print(f"Original hash: {original_hash}")
-        print(f"New hash: {new_hash}")
-    else:
-        sys.exit(1)
+
+if __name__ == "__main__":
+    main()