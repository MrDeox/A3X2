--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -4,110 +4,70 @@
 import re
 from pathlib import Path
 
-class SecurePatchApplier:
-    def __init__(self):
-        self.target_dir = '.'
-        self.strip_level = 0
-        self.dry_run = False
-        self.verbose = False
+# Security checks
+def validate_patch_content(patch_content):
+    # Basic validation: ensure it's a valid unified diff
+    if not re.search(r'^\+{3} ', patch_content, re.MULTILINE):
+        raise ValueError('Invalid patch format: missing +++ header')
+    if not re.search(r'^\-{3} ', patch_content, re.MULTILINE):
+        raise ValueError('Invalid patch format: missing --- header')
+    # Check for potentially dangerous commands (e.g., shell injection)
+    dangerous_patterns = [r';\s*(rm|mv|cp|chmod|chown)', r'\$\(.*?\)', r'`.*?`']
+    for pattern in dangerous_patterns:
+        if re.search(pattern, patch_content, re.IGNORECASE):
+            raise ValueError('Patch contains potentially dangerous content')
+    return True
 
-    def parse_arguments(self, args):
-        i = 0
-        while i < len(args):
-            if args[i] == '-p' or args[i] == '--strip':
-                i += 1
-                if i < len(args):
-                    self.strip_level = int(args[i])
-                    i += 1
-            elif args[i] == '--dry-run':
-                self.dry_run = True
-                i += 1
-            elif args[i] == '-v' or args[i] == '--verbose':
-                self.verbose = True
-                i += 1
-            elif args[i].startswith('-'):
-                print(f"Unknown option: {args[i]}")
-                sys.exit(1)
-            else:
-                if not hasattr(self, 'patch_file'):
-                    self.patch_file = args[i]
-                    i += 1
-                else:
-                    self.target_dir = args[i]
-                    i += 1
-        if not hasattr(self, 'patch_file'):
-            print("Usage: python patch.py [options] <patchfile> [target_dir]")
-            sys.exit(1)
+def validate_file_path(file_path):
+    # Ensure path is safe: no absolute paths outside working dir, no .. escapes
+    abs_path = os.path.abspath(file_path)
+    if not abs_path.startswith(os.getcwd()):
+        raise ValueError('File path outside current directory')
+    if '..' in file_path or file_path.startswith('/'):
+        raise ValueError('Invalid file path: traversal attempt detected')
+    if os.path.islink(file_path):
+        raise ValueError('File path is a symlink, not allowed for security')
+    return True
 
-    def validate_patch_file(self, patch_path):
-        if not os.path.exists(patch_path):
-            raise FileNotFoundError(f"Patch file not found: {patch_path}")
-        if not os.path.isfile(patch_path):
-            raise ValueError(f"Patch path is not a file: {patch_path}")
-        with open(patch_path, 'r') as f:
-            content = f.read()
-        if not re.search(r'^diff ', content, re.MULTILINE):
-            raise ValueError("Invalid patch format: No 'diff' lines found")
-        # Basic security: Check for suspicious commands (e.g., rm, exec)
-        suspicious_patterns = [r'\s*rm\s', r'\s*exec\s', r'\s*eval\s']
-        for pattern in suspicious_patterns:
-            if re.search(pattern, content, re.IGNORECASE):
-                raise ValueError(f"Potential security risk in patch: {pattern}")
-        if self.verbose:
-            print("Patch file validated successfully.")
+def safe_apply_patch(patch_file, target_file, strip=0):
+    # Read and validate patch
+    with open(patch_file, 'r') as f:
+        patch_content = f.read()
+    validate_patch_content(patch_content)
 
-    def find_target_files(self, patch_content):
-        # Extract file paths from diff headers
-        file_paths = re.findall(r'^---\s+(a/)?(.*)', patch_content, re.MULTILINE)
-        targets = []
-        for _, path in file_paths:
-            full_path = os.path.join(self.target_dir, path.lstrip('/'))
-            if os.path.exists(full_path):
-                targets.append(full_path)
-            else:
-                print(f"Warning: Target file does not exist: {full_path}")
-        return targets
+    # Validate target file
+    validate_file_path(target_file)
 
-    def apply_patch(self):
-        try:
-            with open(self.patch_file, 'r') as f:
-                patch_content = f.read()
-            self.validate_patch_file(self.patch_file)
-            targets = self.find_target_files(patch_content)
-            if not targets:
-                print("No target files found.")
-                return
-            cmd = ['patch', '-p' + str(self.strip_level), '-i', self.patch_file, '-d', self.target_dir]
-            if self.dry_run:
-                cmd.append('--dry-run')
-            if self.verbose:
-                cmd.append('-v')
-            # Security: Use list for subprocess to avoid shell injection
-            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
-            if self.dry_run:
-                print("Dry run successful. No changes applied.")
-            else:
-                print("Patch applied successfully.")
-            if self.verbose:
-                print(result.stdout)
-        except subprocess.CalledProcessError as e:
-            print(f"Failed to apply patch: {e}")
-            print(e.stderr)
-            sys.exit(1)
-        except Exception as e:
-            print(f"Error: {e}")
-            sys.exit(1)
+    # Prepare command with sanitized inputs
+    cmd = ['patch', f'--strip={strip}', '-i', patch_file, target_file]
+    # Run with limited environment to prevent injection
+    env = os.environ.copy()
+    env['PATH'] = '/usr/bin:/bin'  # Restrict PATH
 
-    def backup_targets(self, targets):
-        for target in targets:
-            backup = target + '.bak'
-            if not os.path.exists(backup):
-                os.rename(target, backup)
-                print(f"Backup created: {backup}")
+    try:
+        result = subprocess.run(cmd, capture_output=True, text=True, env=env, timeout=30)
+        if result.returncode != 0:
+            raise subprocess.CalledProcessError(result.returncode, cmd, result.stdout, result.stderr)
+        return result.stdout
+    except subprocess.TimeoutExpired:
+        raise TimeoutError('Patch application timed out')
+    except FileNotFoundError:
+        raise RuntimeError('Patch command not found')
 
 if __name__ == '__main__':
-    applier = SecurePatchApplier()
-    applier.parse_arguments(sys.argv[1:])
-    # Optional: Backup before applying
-    # applier.backup_targets(applier.find_target_files(open(applier.patch_file).read()))
-    applier.apply_patch()+    if len(sys.argv) < 3:
+        print('Usage: python patch.py <patch_file> <target_file> [strip_level]')
+        sys.exit(1)
+
+    patch_file = sys.argv[1]
+    target_file = sys.argv[2]
+    strip = int(sys.argv[3]) if len(sys.argv) > 3 else 0
+
+    try:
+        validate_file_path(patch_file)
+        output = safe_apply_patch(patch_file, target_file, strip)
+        print('Patch applied successfully')
+        print(output)
+    except Exception as e:
+        print(f'Error: {e}')
+        sys.exit(1)
