--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -2,48 +2,89 @@
 import sys
 import os
 import subprocess
-import re
+import tempfile
+import hashlib
 
-# Security checks function
-def security_check(patch_content):
-    high_risk_patterns = [
-        r'subprocess\.call\(\s*["\']rm["\'][^,]*,',
-        r'os\.system\(\s*["\']del["\'][^,]*,',
-        r'exec\(\s*["\'][^;]*;',
-        r'eval\(\s*input\(\s*',
-        # Add more patterns for dangerous operations
-    ]
-    for pattern in high_risk_patterns:
-        if re.search(pattern, patch_content, re.IGNORECASE):
-            return {'patch_apply': 'high'}
-    return None
 
-# Main patch application with security
-def apply_secure_patch(patch_file):
+def validate_patch(patch_content):
+    # Basic validation: check if it's a valid diff
+    if not patch_content.startswith(('---', '+++', 'diff ')):
+        return False, "Invalid patch format"
+    # Check for malicious content, e.g., no exec or dangerous commands
+    dangerous_keywords = ['exec(', 'eval(', 'os.system', 'subprocess.call']
+    for keyword in dangerous_keywords:
+        if keyword in patch_content:
+            return False, f"Dangerous keyword detected: {keyword}"
+    return True, "Valid"
+
+
+def compute_file_hash(filepath):
+    hasher = hashlib.sha256()
+    with open(filepath, 'rb') as f:
+        for chunk in iter(lambda: f.read(4096), b''):
+            hasher.update(chunk)
+    return hasher.hexdigest()
+
+
+def apply_secure_patch(patch_file, target_file, backup=True):
+    if not os.path.exists(target_file):
+        print(f"Error: Target file {target_file} does not exist.")
+        return False
+
+    if not os.access(target_file, os.R_OK | os.W_OK):
+        print(f"Error: Insufficient permissions for {target_file}")
+        return False
+
+    # Read patch content
     with open(patch_file, 'r') as f:
         patch_content = f.read()
-    risks = security_check(patch_content)
-    if risks:
-        print(f"Patch rejected due to high risks: {risks}")
-        return False
-    try:
-        result = subprocess.run(['patch', '-p1', '<', patch_file], capture_output=True, text=True)
-        if result.returncode == 0:
-            print("Patch applied successfully.")
-            return True
-        else:
-            print(f"Failed to apply patch: {result.stderr}")
-            return False
-    except Exception as e:
-        print(f"Error: {e}")
+
+    is_valid, msg = validate_patch(patch_content)
+    if not is_valid:
+        print(f"Patch validation failed: {msg}")
         return False
 
-if __name__ == "__main__":
-    if len(sys.argv) != 2:
-        print("Usage: python patch.py <patch_file>")
+    original_hash = compute_file_hash(target_file)
+
+    if backup:
+        backup_file = target_file + '.bak'
+        os.rename(target_file, backup_file)
+
+    try:
+        # Use subprocess to apply patch safely
+        cmd = ['patch', '-p1', '--input=' + patch_file, target_file]
+        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
+        print(f"Patch applied successfully: {result.stdout}")
+        return True
+    except subprocess.CalledProcessError as e:
+        print(f"Patch application failed: {e.stderr}")
+        if backup:
+            os.rename(backup_file, target_file)  # Restore backup
+        return False
+    except Exception as e:
+        print(f"Unexpected error: {e}")
+        if backup:
+            os.rename(backup_file, target_file)
+        return False
+
+
+if __name__ == '__main__':
+    if len(sys.argv) < 3:
+        print("Usage: python patch.py <patch_file> <target_file> [--no-backup]")
         sys.exit(1)
+
     patch_file = sys.argv[1]
+    target_file = sys.argv[2]
+    backup = '--no-backup' not in sys.argv
+
     if not os.path.exists(patch_file):
-        print("Patch file not found.")
+        print(f"Error: Patch file {patch_file} does not exist.")
         sys.exit(1)
-    apply_secure_patch(patch_file)
+
+    success = apply_secure_patch(patch_file, target_file, backup)
+    if success:
+        new_hash = compute_file_hash(target_file)
+        print(f"Original hash: {original_hash}")
+        print(f"New hash: {new_hash}")
+    else:
+        sys.exit(1)
