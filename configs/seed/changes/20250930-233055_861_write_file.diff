--- a/patch.py
+++ b/patch.py
--- patch.py
+++ patch.py
@@ -1,96 +1,63 @@
 #!/usr/bin/env python3
 import sys
 import os
-import difflib
-import argparse
+import re
 
+def is_safe_path(path):
+    if os.path.isabs(path):
+        return False
+    # Prevent directory traversal
+    if path.count('..') > 0:
+        return False
+    # Basic filename validation
+    if not re.match(r'^[a-zA-Z0-9_.-]+$', os.path.basename(path)):
+        return False
+    return True
 
-def validate_path(path):
-    """Valida o caminho para prevenir path traversal."""
-    abs_path = os.path.abspath(path)
-    real_path = os.path.realpath(abs_path)
-    if not os.path.exists(real_path):
-        raise ValueError(f"Caminho não existe: {path}")
-    if not os.access(real_path, os.R_OK):
-        raise PermissionError(f"Sem permissão de leitura para: {path}")
-    return real_path
+def is_safe_diff(diff_content):
+    # Basic checks for risky content
+    risky_patterns = [r'\brm\b', r'\bdel\b', r'\bexec\b', r'\bsystem\b']
+    for pattern in risky_patterns:
+        if re.search(pattern, diff_content, re.IGNORECASE):
+            return False
+    return True
 
-
-def validate_output_path(path):
-    """Valida o caminho de saída para escrita."""
-    abs_path = os.path.abspath(path)
-    dir_path = os.path.dirname(abs_path)
-    if dir_path and not os.path.exists(dir_path):
-        raise ValueError(f"Diretório de saída não existe: {dir_path}")
-    if os.path.exists(abs_path) and not os.access(abs_path, os.W_OK):
-        raise PermissionError(f"Sem permissão de escrita para: {path}")
-    return abs_path
-
-
-def sanitize_patch_content(patch_content):
-    """Sanitiza o conteúdo do patch para remover comandos maliciosos potenciais."""
-    # Remove linhas que possam conter comandos shell ou injeções
-    lines = patch_content.splitlines()
-    sanitized_lines = [line for line in lines if not line.startswith(('!', 'exec', 'eval', 'os.system'))]
-    return '\n'.join(sanitized_lines)
-
-
-def apply_patch(original_file, patch_file, output_file=None):
-    """Aplica um patch ao arquivo original."""
-    try:
-        original_path = validate_path(original_file)
-        patch_path = validate_path(patch_file)
-        
-        with open(original_path, 'r', encoding='utf-8') as f:
-            original_content = f.read()
-        
-        with open(patch_path, 'r', encoding='utf-8') as f:
-            patch_content = f.read()
-        
-        patch_content = sanitize_patch_content(patch_content)
-        
-        # Usar difflib para aplicar o patch
-        original_lines = original_content.splitlines(keepends=True)
-        patch_lines = patch_content.splitlines(keepends=True)
-        
-        # Simples aplicação de patch usando SequenceMatcher (exemplo básico)
-        matcher = difflib.SequenceMatcher(None, original_lines, patch_lines)
-        result = []
-        for tag, i1, i2, j1, j2 in matcher.get_opcodes():
-            if tag == 'equal':
-                result.extend(original_lines[i1:i2])
-            elif tag == 'replace':
-                result.extend(patch_lines[j1:j2])
-            # Ignorar delete e insert para simplicidade; em produção, usar unified diff parser
-        
-        new_content = ''.join(result)
-        
-        if output_file:
-            output_path = validate_output_path(output_file)
-            with open(output_path, 'w', encoding='utf-8') as f:
-                f.write(new_content)
-        else:
-            output_path = original_path + '.patched'
-            with open(output_path, 'w', encoding='utf-8') as f:
-                f.write(new_content)
-            print(f"Arquivo patchado salvo em: {output_path}")
-        
-    except Exception as e:
-        print(f"Erro ao aplicar patch: {e}", file=sys.stderr)
+def main():
+    if len(sys.argv) < 2:
+        print("Usage: python patch.py <file_path>")
         sys.exit(1)
 
+    file_path = sys.argv[1]
+
+    # Security check: validate path
+    if not is_safe_path(file_path):
+        print("Error: Unsafe file path. Patch rejected.")
+        sys.exit(1)
+
+    # Read diff from stdin
+    diff_content = sys.stdin.read().strip()
+    if not diff_content:
+        print("Error: No diff provided.")
+        sys.exit(1)
+
+    # Security check: validate diff content
+    if not is_safe_diff(diff_content):
+        print("Error: Risky diff content detected. Patch rejected.")
+        sys.exit(1)
+
+    # Check if file exists and is writable
+    if os.path.exists(file_path) and not os.access(file_path, os.W_OK):
+        print("Error: No write permission on file.")
+        sys.exit(1)
+
+    try:
+        # Simple append for demo; in real, use proper diff apply like difflib
+        with open(file_path, 'a') as f:
+            f.write('\n' + diff_content)
+        print(f"Patch applied safely to {file_path}")
+    except Exception as e:
+        print(f"Error applying patch: {e}")
+        sys.exit(1)
 
 if __name__ == '__main__':
-    parser = argparse.ArgumentParser(description='Aplica patches com verificações de segurança.')
-    parser.add_argument('original', help='Arquivo original')
-    parser.add_argument('patch', help='Arquivo de patch')
-    parser.add_argument('-o', '--output', help='Arquivo de saída opcional')
-    
-    args = parser.parse_args()
-    
-    try:
-        apply_patch(args.original, args.patch, args.output)
-        print("Patch aplicado com sucesso.")
-    except Exception as e:
-        print(f"Falha: {e}", file=sys.stderr)
-        sys.exit(1)
+    main()