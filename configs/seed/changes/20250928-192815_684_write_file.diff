--- a/agent.py
+++ b/agent.py
--- agent.py
+++ agent.py
@@ -1,7 +1,7 @@
 # Basic Agent for Dynamic Recursion Monitoring with Metrics Feedback
+
 import json
 import os
-import subprocess
 import sys
 from typing import Dict, Any, List
 
@@ -14,94 +14,108 @@
         self.success_rate = 0.0
         self.history: List[Dict[str, Any]] = []
 
-    def update_action(self, success: bool):
+    def record_action(self, success: bool, depth: int):
         self.actions_total += 1
         if success:
             self.actions_success += 1
-        self.success_rate = self.actions_success / self.actions_total if self.actions_total > 0 else 0.0
-        self._adjust_depth()
+        self.recursion_depth = max(self.recursion_depth, depth)
+        self.update_success_rate()
+        self.history.append({
+            'success': success,
+            'depth': depth,
+            'total': self.actions_total,
+            'rate': self.success_rate
+        })
 
-    def _adjust_depth(self):
-        if self.recursion_depth > self.max_depth and self.success_rate > 0.9:
+    def update_success_rate(self):
+        if self.actions_total > 0:
+            self.success_rate = self.actions_success / self.actions_total
+        else:
+            self.success_rate = 0.0
+
+    def adjust_depth(self):
+        if self.success_rate > 0.9 and self.max_depth < 10:  # Auto-adjust up to 10
             self.max_depth += 1
             print(f"Auto-adjusted max_depth to {self.max_depth} based on success_rate {self.success_rate:.2f}")
-        elif self.success_rate < 0.8 and self.max_depth > 5:
+        elif self.success_rate < 0.7 and self.max_depth > 3:
             self.max_depth -= 1
-            print(f"Reduced max_depth to {self.max_depth} due to low success_rate {self.success_rate:.2f}")
+            print(f"Auto-adjusted max_depth to {self.max_depth} based on success_rate {self.success_rate:.2f}")
 
-    def log_action(self, action: str, obs: str, success: bool):
-        entry = {"action": action, "observation": obs, "success": success}
-        self.history.append(entry)
-        self.update_action(success)
+    def should_recurse(self, current_depth: int) -> bool:
+        return current_depth < self.max_depth
 
-    def auto_commit_if_ready(self):
-        if self.success_rate > 0.9 and self.actions_total > 0:
-            try:
-                subprocess.run(["git", "add", "."], check=True, cwd="/home/arthur/Projetos/A3X")
-                subprocess.run(["git", "commit", "-m", f"Auto-commit: success_rate {self.success_rate:.2f}, actions {self.actions_total}"], check=True, cwd="/home/arthur/Projetos/A3X")
-                print("Auto-commit successful")
-            except subprocess.CalledProcessError:
-                print("Auto-commit failed")
+    def get_metrics(self) -> Dict[str, Any):
+        return {
+            'actions_total': self.actions_total,
+            'actions_success_rate': self.success_rate,
+            'recursion_depth': self.recursion_depth,
+            'max_depth': self.max_depth,
+            'history_length': len(self.history)
+        }
 
-class Agent:
-    def __init__(self):
-        self.metrics = MetricsTracker()
-        self.max_recursion = 10  # Initial limit
-        self.current_depth = 0
+class RecursiveAgent:
+    def __init__(self, metrics_tracker: MetricsTracker = None):
+        self.metrics = metrics_tracker or MetricsTracker()
+        self.base_path = '/home/arthur/Projetos/A3X/configs'
 
-    def execute(self, objective: str, iteration: int, history: List[Dict] = None):
-        if history:
-            # Parse history to update metrics
-            for entry in history:
-                if "ACTION" in entry and "OBS" in entry:
-                    action = entry["ACTION"]
-                    obs = entry["OBS"]
-                    success = "OK" in obs or "concluÃ­do" in obs
-                    self.metrics.log_action(action, obs, success)
-        self.current_depth += 1
-        if self.current_depth > self.max_recursion:
-            print("Max recursion exceeded")
-            return {"type": "finish", "text": "Recursion limit reached"}
+    def execute_task(self, task: str, current_depth: int = 0) -> Dict[str, Any]:
+        if not self.metrics.should_recurse(current_depth):
+            return {'status': 'depth_limit', 'message': f'Depth {current_depth} exceeds max {self.metrics.max_depth}'}
 
-        # Decide next action based on objective
-        if iteration == 1:
-            # Initial setup
-            return self._read_file("/home/arthur/Projetos/A3X/configs/agent.py")
-        elif "implementar monitoramento" in objective.lower():
-            # Add monitoring logic
-            return self._write_monitoring_code()
+        print(f"Executing task: {task} at depth {current_depth}")
+
+        # Simulate action execution
+        success = self._simulate_action(task, current_depth)
+        self.metrics.record_action(success, current_depth)
+        self.metrics.adjust_depth()
+
+        if success and self.metrics.should_recurse(current_depth + 1):
+            # Recursive call for sub-tasks
+            sub_result = self.execute_task(f"Sub-task of {task}", current_depth + 1)
+            return {'status': 'success', 'sub_result': sub_result, 'metrics': self.metrics.get_metrics()}
         else:
-            # Generic action
-            return {"type": "message", "text": f"Processing iteration {iteration} with depth {self.current_depth}"}
+            if self.metrics.success_rate > 0.9:
+                self._auto_commit()
+            return {'status': 'success' if success else 'failure', 'metrics': self.metrics.get_metrics()}
 
-    def _read_file(self, path: str) -> Dict[str, Any]:
+    def _simulate_action(self, task: str, depth: int) -> bool:
+        # Placeholder for actual action; assume high success for testing
+        return True  # Simulate 100% success initially
+
+    def _auto_commit(self):
         try:
-            with open(path, 'r') as f:
-                content = f.read()
-            self.metrics.log_action(f"READ_FILE {path}", "OK", True)
-            return {"type": "read_file", "path": path, "content": content}
-        except FileNotFoundError:
-            self.metrics.log_action(f"READ_FILE {path}", "FAIL (File not found)", False)
-            return {"type": "write_file", "path": path, "content": "# Initial skeleton\nclass Agent:\n    pass"}
+            os.system('git add . && git commit -m "Auto-commit: High success rate achieved"')
+            print("Auto-commit executed.")
+        except Exception as e:
+            print(f"Auto-commit failed: {e}")
 
-    def _write_monitoring_code(self) -> Dict[str, Any]:
-        content = '''# Full implementation with dynamic monitoring
-import json  # ... (previous code + new features)'''
-        # Simulate writing enhanced code
-        return {"type": "write_file", "path": "/home/arthur/Projetos/A3X/configs/agent.py", "content": content}
+# Test suite
+def run_tests():
+    agent = RecursiveAgent()
+    results = []
 
-    def run_tests(self):
-        # Simple test for metrics
-        test_success = self.metrics.success_rate > 0.9
-        print(f"Test: success_rate check - {test_success}")
-        self.metrics.auto_commit_if_ready()
-        return test_success
+    # Test 1: Basic execution at depth 0
+    result1 = agent.execute_task("Test Task 1", 0)
+    results.append(result1)
 
-# Usage example
+    # Test 2: Recursion up to depth 3
+    result2 = agent.execute_task("Test Task 2", 0)
+    results.append(result2)
+
+    # Test 3: Force depth >5 to check adjustment
+    agent.metrics.max_depth = 6
+    result3 = agent.execute_task("Deep Test Task", 0)
+    results.append(result3)
+
+    # Simulate some failures to test rate
+    agent.metrics.record_action(False, 1)
+    agent.metrics.record_action(True, 2)
+    agent.metrics.adjust_depth()
+
+    print("Test Results:", results)
+    print("Final Metrics:", agent.metrics.get_metrics())
+    assert agent.metrics.success_rate >= 0.8, "Success rate too low"
+    print("All tests passed!")
+
 if __name__ == "__main__":
-    agent = Agent()
-    # Simulate execution
-    for i in range(1, 11):
-        result = agent.execute("Implement monitoring", i)
-        print(result)
-    agent.run_tests()+    run_tests()